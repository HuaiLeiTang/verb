<!DOCTYPE html>

<html>
<head>
  <title>verb.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>verb.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>browser context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">if</span> ( <span class="hljs-keyword">typeof</span> exports != <span class="hljs-string">'object'</span> || exports === <span class="hljs-literal">undefined</span> )  
{
	<span class="hljs-keyword">var</span> verb = {}
		, numeric = window.numeric
		, binomial = window.binomial
		, labor = window.labor;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>node.js context</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-keyword">else</span> 
{
	<span class="hljs-keyword">var</span> verb = module.exports = {}
		, numeric = <span class="hljs-built_in">require</span>(<span class="hljs-string">'numeric'</span>)
		, binomial = <span class="hljs-built_in">require</span>(<span class="hljs-string">'binomial'</span>)
		, labor = <span class="hljs-built_in">require</span>(<span class="hljs-string">'labor'</span>);
}</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>Initialize the verb namespace objects</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom = verb.geom || {};
verb.core = verb.core || {};
verb.eval = verb.eval || {};
verb.intersect = verb.intersect || {};
verb.eval.nurbs = verb.eval.nurbs || {};
verb.eval.geom = verb.eval.geom || {};
verb.eval.mesh = verb.eval.mesh || {};</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <h4 id="verb-epsilon">verb.EPSILON</h4>
<p>Used for numeric comparisons</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.EPSILON = <span class="hljs-number">1e-8</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <h4 id="verb-tolerance">verb.TOLERANCE</h4>
<p>Default tolerance for geometric operations - defines &quot;close enough&quot; 
for tesselation, intersection, and more</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.TOLERANCE = <span class="hljs-number">1e-3</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <h4 id="init-">init()</h4>
<p>Start a default Engine</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.init = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
	verb.nurbsEngine = <span class="hljs-keyword">new</span> verb.core.Engine( verb.eval.nurbs );
	verb.geom.NurbsGeometry.prototype.nurbsEngine = verb.nurbsEngine;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <h4 id="douglas-crockford-s-method-">Douglas Crockford&#39;s &quot;method&quot;</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">Function</span>.prototype.method = <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(name, func)</span> {</span>
    <span class="hljs-keyword">this</span>.prototype[name] = func;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h4 id="douglas-crockford-s-inherits-">Douglas Crockford&#39;s &quot;inherits&quot;</h4>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">Function</span>.method(<span class="hljs-string">'inherits'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-params">(parent)</span> {</span>
    <span class="hljs-keyword">this</span>.prototype = <span class="hljs-keyword">new</span> parent();
    <span class="hljs-keyword">var</span> d = {}, 
        p = <span class="hljs-keyword">this</span>.prototype;
    <span class="hljs-keyword">this</span>.prototype.constructor = parent; 
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
});</pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <h4 id="array-flatten-">Array.flatten()</h4>
<p>Extend methods to collapse multidimensional arrays to 1d</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-built_in">Array</span>.prototype.flatten = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];

	<span class="hljs-keyword">var</span> merged = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++){
		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>[i] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>){
			merged = merged.concat( <span class="hljs-keyword">this</span>[i].flatten() );
		} <span class="hljs-keyword">else</span> {
			merged = merged.concat( <span class="hljs-keyword">this</span>[i] );
		}
	}

	<span class="hljs-keyword">return</span> merged;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <h4 id="numeric-normalized-arr-">numeric.normalized( arr )</h4>
<p>Extend numeric to obtain the normalized version of an array</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of numbers</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, The array after normalization</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>numeric.normalized = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span>{</span>

	<span class="hljs-keyword">return</span> numeric.div( arr, numeric.norm2(arr) );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <h4 id="numeric-cross-u-v-">numeric.cross( u, v )</h4>
<p>Extend numeric to form the cross product between two length 3 arrays</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array of numbers</li>
<li><em>Array</em>, Length 3 array of numbers</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, The length 3 array cross product</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>numeric.cross = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(u, v)</span>{</span>

	<span class="hljs-keyword">return</span> [u[<span class="hljs-number">1</span>]*v[<span class="hljs-number">2</span>]-u[<span class="hljs-number">2</span>]*v[<span class="hljs-number">1</span>],u[<span class="hljs-number">2</span>]*v[<span class="hljs-number">0</span>]-u[<span class="hljs-number">0</span>]*v[<span class="hljs-number">2</span>],u[<span class="hljs-number">0</span>]*v[<span class="hljs-number">1</span>]-u[<span class="hljs-number">1</span>]*v[<span class="hljs-number">0</span>]];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <h4 id="left-arr-">left(arr)</h4>
<p>Get the first half of an array including the pivot</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of stuff</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, the right half</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.left = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span>{</span> 
	<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.ceil( arr.length / <span class="hljs-number">2</span> ); 
	<span class="hljs-keyword">return</span> arr.slice( <span class="hljs-number">0</span>, len );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <h4 id="right-arr-">right(arr)</h4>
<p>Get the second half of an array, not including the pivot</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of stuff</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, the right half</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.right = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span>{</span>
	<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.ceil( arr.length / <span class="hljs-number">2</span> );
	<span class="hljs-keyword">return</span> arr.slice( len );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <h4 id="rightwithpivot-arr-">rightWithPivot(arr)</h4>
<p>Get the second half of an array including the pivot</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of stuff</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, the right half</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.rightWithPivot = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arr)</span>{</span>
	<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];
	<span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.ceil( arr.length / <span class="hljs-number">2</span> );
	<span class="hljs-keyword">return</span> arr.slice( len-<span class="hljs-number">1</span> );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <h4 id="unique-arr-comparator-">unique(arr, comparator)</h4>
<p>Obtain the unique set of elements in an array</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of stuff</li>
<li><em>Function</em>, a function that receives two arguments (two objects from the array).  Returning true indicates
the objects are equal.  </li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of unique elements</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.unique = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( arr, comparator )</span>{</span>

	<span class="hljs-keyword">if</span> (arr.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> [];

	<span class="hljs-keyword">var</span> uniques = [ arr.pop() ];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.length; i++ ){

		<span class="hljs-keyword">var</span> ele = arr.pop();
		<span class="hljs-keyword">var</span> isUnique = <span class="hljs-literal">true</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; uniques.length; j++ ){
			<span class="hljs-keyword">if</span> ( comparator( ele, uniques[i] ) ){
				isUnique = <span class="hljs-literal">false</span>;
				<span class="hljs-keyword">break</span>;
			}
		}

		<span class="hljs-keyword">if</span> ( isUnique ){
			uniques.push( ele );
		}

	}

	<span class="hljs-keyword">return</span> uniques;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <h4 id="range-start-stop-step-">range(start, stop, step)</h4>
<p>Obtain a range of numbers</p>
<p>Borrowed from underscore.js port of the python function
of the same name</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, start point</li>
<li><em>Number</em>, end point </li>
<li><em>Number</em>, step</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, range array</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>  verb.range = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(start, stop, step)</span> {</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">arguments</span>.length &lt;= <span class="hljs-number">1</span>) {
      stop = start || <span class="hljs-number">0</span>;
      start = <span class="hljs-number">0</span>;
    }
    step = <span class="hljs-built_in">arguments</span>[<span class="hljs-number">2</span>] || <span class="hljs-number">1</span>;

    <span class="hljs-keyword">var</span> len = <span class="hljs-built_in">Math</span>.max(<span class="hljs-built_in">Math</span>.ceil((stop - start) / step), <span class="hljs-number">0</span>);
    <span class="hljs-keyword">var</span> idx = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">var</span> range = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(len);

    <span class="hljs-keyword">while</span>(idx &lt; len) {
      range[idx++] = start;
      start += step;
    }

    <span class="hljs-keyword">return</span> range;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <h3 id="new-engine-options-">new Engine( [options] )</h3>
<p>Constructor for Engine</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, An options object defining the library location, number of threads to use, tolerance of the worker, etc.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.core.Engine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>private properties</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> _use_pool = ( <span class="hljs-keyword">typeof</span> Worker === <span class="hljs-string">'function'</span> ) &amp;&amp; ( options.use_pool || options.use_pool === <span class="hljs-literal">undefined</span> );
	<span class="hljs-keyword">var</span> _num_threads = options.num_workers || <span class="hljs-number">2</span>;
	<span class="hljs-keyword">var</span> _tolerance = options.tolerance || <span class="hljs-number">1e-4</span>;
	<span class="hljs-keyword">var</span> _url = options.url || <span class="hljs-string">'js/verbEval.js'</span>;
	<span class="hljs-keyword">var</span> _lib = options.library || verb.eval.nurbs;
	<span class="hljs-keyword">var</span> _error_handler = options.error_handler || ( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( message )</span> {</span> console.warn( message ); } );
	<span class="hljs-keyword">var</span> _pool = <span class="hljs-literal">undefined</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>private methods</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> init_pool = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

		<span class="hljs-keyword">try</span> {
			_pool = <span class="hljs-keyword">new</span> labor.Pool(_url, _num_threads );
			_pool.start();
		} <span class="hljs-keyword">catch</span> (err) {
			_error_handler( <span class="hljs-string">'Failed to initialize labor.Pool: '</span> + err );
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		}
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;

	};

	<span class="hljs-keyword">var</span> eval_sync = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func, arguments_array)</span> {</span>
		<span class="hljs-keyword">return</span> _lib[func].apply(<span class="hljs-literal">null</span>, arguments_array);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              <h4 id="start-">start()</h4>
<p>Creates the thread pool if that is being used</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.start = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>initialize pool</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> ( _use_pool )
		{
			init_pool();
		}
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <h4 id="eval-func-arguments_array-callback-">eval(func, arguments_array, callback )</h4>
<p>Evaluate a function asynchronously from the library</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the function to call in the library</li>
<li><em>Array</em>, The array of arguments to the function</li>
<li><em>Function</em>, Function to execute on completion, passing the value to it</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Unknown</em>, the return value of the function</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.eval = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(func, arguments_array, callback )</span>
	{</span>

		<span class="hljs-keyword">if</span> (!callback){
			<span class="hljs-keyword">return</span> eval_sync(func, arguments_array);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>if we are to use the pool we must init it </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> ( _use_pool &amp;&amp; ( _pool || ( _pool === <span class="hljs-literal">undefined</span> &amp;&amp; init_pool() ) ) ) {
			_pool.addWork( func, arguments_array, callback );
		}	<span class="hljs-keyword">else</span> {
			setTimeout( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> callback( eval_sync(func, arguments_array ) ) }, <span class="hljs-number">0</span>);
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <h4 id="settolerance-tolerance-">setTolerance( tolerance )</h4>
<p>Set the tolerance of the library</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The tolerance value</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setTolerance = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(tolerance)</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>TODO: send message to worker pool in labor.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		_tolerance = tolerance;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <h4 id="setusepool-use_pool-">setUsePool( use_pool )</h4>
<p>Whether to use the thread pool or do evaluations in the main thread</p>
<p><strong>params</strong></p>
<ul>
<li><em>Boolean</em>, Use the pool or not</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setUsePool = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( use_pool )</span> {</span>

		<span class="hljs-keyword">if</span> ( use_pool &amp;&amp; _pool === <span class="hljs-literal">undefined</span> &amp;&amp; init_pool() ) {
			_use_pool = use_pool;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( !use_pool ) {
			_pool = <span class="hljs-literal">null</span>;
			<span class="hljs-keyword">delete</span> _pool;
			<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
		}
		
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <h4 id="seterrorhandler-handler-">setErrorHandler( handler )</h4>
<p>The error handler function</p>
<p><strong>params</strong></p>
<ul>
<li><em>Function</em>, The function that handles errors</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setErrorHandler = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( handler )</span> {</span>
		_error_handler = handler;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <h4 id="setnumthreads-numthreads-">setNumThreads( numThreads )</h4>
<p>Set the number of threads to use</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The number of threads to use</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setNumThreads = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( num_threads )</span> {</span>
		_num_threads = num_threads;</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p>TODO: implement add or remove workers in labor.js</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	}

};</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <h3 id="new-watchobject-">new WatchObject()</h3>
<p>Constructor for WatchObject</p>
<p>WatchObject is a simple type with observable properties.  You can register callbacks for
when these properties change</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.core.WatchObject = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>name -&gt; { id -&gt; callback }</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> watchers = { <span class="hljs-string">"change"</span> : {} };</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>name -&gt; value</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> properties = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>counter for watch ids</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> watcherId = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>report a property change to the watchers</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> report = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(name, updateObject)</span>{</span>

		<span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">"string"</span>){

			<span class="hljs-keyword">for</span> (ele <span class="hljs-keyword">in</span> watchers[name]){
				watchers[name][ele]( updateObject );
			}

			<span class="hljs-keyword">for</span> (ele <span class="hljs-keyword">in</span> watchers[<span class="hljs-string">"change"</span>]){
				watchers[<span class="hljs-string">"change"</span>][ele]( updateObject );
			}
			
		} <span class="hljs-keyword">else</span> {
			<span class="hljs-keyword">for</span> (n <span class="hljs-keyword">in</span> name){
				report( n, updateObject );
			}
		}

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <h4 id="eval-func-arguments_array-callback-">eval(func, arguments_array, callback )</h4>
<p>Get the value of a property name. </p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Unknown</em>, The value of the property</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.get = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name )</span>{</span>

		<span class="hljs-keyword">return</span> properties[name];

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <h4 id="set-name-value-">set( name, value )</h4>
<p>Set the value of a property and update watchers.  Initializes the value if it doesn&#39;t already exist</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
<li><em>Unknown</em>, The new value for the property</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.set = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name, value )</span>{</span>

		<span class="hljs-keyword">var</span> old = properties[name];

		properties[name] = value;
		watchers[name] = watchers[name] || {};

		report( name, {name: name, old: old, <span class="hljs-string">"new"</span>: value, target: that, type: <span class="hljs-string">"full"</span>});

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <h4 id="setall-propertynamevaluepairs-">setAll( propertyNameValuePairs )</h4>
<p>Set the value of a collection of properties simultaneously</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, An object literal mapping from property names to new values</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setAll = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( propertyNameValuePairs )</span>{</span>

		<span class="hljs-keyword">var</span> oldVals = {};

		<span class="hljs-keyword">for</span> ( propName <span class="hljs-keyword">in</span> propertyNameValuePairs ){
			oldVals[propName] = properties[propName];
			properties[propName] = propertyNameValuePairs[propName];
			watchers[propName] = watchers[propName] || {};
		}

		report( propertyNameValuePairs, { old: oldVals, <span class="hljs-string">"new"</span>: propertyNameValuePairs, target: that, type: <span class="hljs-string">"multi"</span> } );

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <h4 id="setat-name-index-value-">setAt( name, index, value  )</h4>
<p>Set the value of an array property at a particular index.  Update watchers
indicating that it is an &quot;index&quot; type update.</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
<li><em>Number</em>, The index at which to change the value</li>
<li><em>Unknown</em>, The new value for the index</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.setAt = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name, index, value )</span>{</span>

		<span class="hljs-keyword">var</span> oldArr = properties[name];

		<span class="hljs-keyword">if</span> (oldArr === <span class="hljs-literal">undefined</span> || oldArr.length &gt;= index || index &lt; <span class="hljs-number">0</span>){
			<span class="hljs-keyword">return</span>;
		}

		<span class="hljs-keyword">var</span> old = properties[name][index];
		properties[name][index] = value;

		report( name, {name: name, index: index, old: old, <span class="hljs-string">"new"</span>: value, target: that, type: <span class="hljs-string">"index"</span>} );

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <h4 id="watch-name-callback-">watch( name, callback )</h4>
<p>Start watching a particular property.  Use &quot;change&quot; as the name to receive all 
updates from this object</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, The name of the property</li>
<li><em>Function</em>, The callback</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, A watcher id which can be used to unregister the callback</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.watch = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name, callback )</span>{</span>

		<span class="hljs-keyword">if</span> ( properties[name] === <span class="hljs-literal">undefined</span> || !callback ){
			<span class="hljs-keyword">return</span>;
		}

		<span class="hljs-keyword">var</span> id = watcherId++;
		watchers[name][watcherId] = callback;

		<span class="hljs-keyword">return</span> watcherId++;
	};</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <h4 id="watchall-names-callback-">watchAll( names, callback )</h4>
<p>Start watching multiple properties</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of property names</li>
<li><em>Function</em>, The callback</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, An array of watcher ids which can be used to unregister the callbacks</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.watchAll = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( names, callback )</span>{</span>

		<span class="hljs-keyword">var</span> watcherIds = [];

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; names.length; i++){
			watcherIds.push( <span class="hljs-keyword">this</span>.watch( names[i], callback ) );
		}

		<span class="hljs-keyword">return</span> watcherIds;

	};</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <h4 id="watchall-names-callback-">watchAll( names, callback )</h4>
<p>Stop watching a property</p>
<p><strong>params</strong></p>
<ul>
<li><em>String</em>, Property name</li>
<li><em>Number</em>, Watcher id to remove</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.ignore = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( name, watcherId )</span>{</span>
	
		<span class="hljs-keyword">if</span> ( watchers[name] === <span class="hljs-literal">undefined</span> 
			|| watchers[name][watcherId] === <span class="hljs-literal">undefined</span>){
			<span class="hljs-keyword">return</span>;
		}

		watchers[name][watcherId] = <span class="hljs-literal">undefined</span>;

	};

};</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <h4 id="uid-">uid()</h4>
<p>Generate a unique id.</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, The id</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.core.uid = (<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
	<span class="hljs-keyword">var</span> id = <span class="hljs-number">0</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> id++;
	};
})();</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <h3 id="new-geometry-">new Geometry()</h3>
<p>Constructor for Geometry</p>
<p>Geometry is the base class for all Geometry types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Geometry = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span> 

	verb.core.WatchObject.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">var</span> id = verb.core.uid();
	
	<span class="hljs-keyword">this</span>.uniqueId = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
		<span class="hljs-keyword">return</span> id;
	};

}.inherits(verb.core.WatchObject);</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <h3 id="new-nurbsgeometry-">new NurbsGeometry()</h3>
<p>Constructor for NurbsGeometry</p>
<p>NurbsGeometry is the base class for all NURBS types</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsGeometry = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

	verb.geom.Geometry.call(<span class="hljs-keyword">this</span>);

}.inherits( verb.geom.Geometry );</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <h3 id="new-nurbssurface-degree-controlpoints-weights-knots-">new NurbsSurface( degree, controlPoints, weights, knots )</h3>
<p>Constructor for a NurbsCurve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The degree of the curve</li>
<li><em>Array</em>, Array of arrays representing the control points</li>
<li><em>Array</em>, Array of numbers representing the control point weights</li>
<li><em>Array</em>, Array of numbers representing the knot structure</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, controlPoints, weights, knots )</span> {</span>

	verb.geom.NurbsGeometry.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"controlPoints"</span>: controlPoints,
		<span class="hljs-string">"weights"</span>: weights,
		<span class="hljs-string">"knots"</span>: knots ? knots.slice(<span class="hljs-number">0</span>) : [],
		<span class="hljs-string">"degree"</span>: degree
	});

}.inherits( verb.geom.NurbsGeometry );</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <h4 id="point-u-callback-">point( u [, callback] )</h4>
<p>Sample a point at the given parameter </p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter to sample the curve</li>
<li><em>Function</em>, Optional callback to do it async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, callback )</span> {</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_point'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(),  u ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <h4 id="derivatives-u-num_derivs-callback-">derivatives( u, num_derivs [, callback] )</h4>
<p>Get derivatives at a given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter to sample the curve</li>
<li><em>Number</em>, The number of derivatives to obtain</li>
<li><em>Number</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.derivatives = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, num_derivs, callback )</span> {</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_derivs'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(),  u, num_derivs  ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <h4 id="tesselate-options-callback-">tesselate(options [, callback] )</h4>
<p>Tesselate a curve at a given tolerance</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The parameter to sample the curve</li>
<li><em>Number</em>, The number of derivatives to obtain</li>
<li><em>Number</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.tesselate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options, callback)</span>{</span>

	<span class="hljs-keyword">var</span> options = options || {};
	options.tolerance = options.tolerance || verb.EPSILON;

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_curve_adaptive_sample'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>), <span class="hljs-keyword">this</span>.homogenize(), options.tolerance ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <h4 id="transform-mat-">transform( mat )</h4>
<p>Transform a curve with the given matrix.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.transform = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mat )</span>{</span>

	<span class="hljs-keyword">var</span> pts = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"controlPoints"</span>);

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		<span class="hljs-keyword">var</span> homoPt = pts[<span class="hljs-number">1</span>].push(<span class="hljs-number">1</span>);
		pts[i] = numeric.mul( mat, homoPt ).slice( <span class="hljs-number">0</span>, homoPt.length-<span class="hljs-number">2</span> );
	}

	<span class="hljs-keyword">this</span>.set(<span class="hljs-string">'controlPoints'</span>, pts);

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <h4 id="clone-">clone()</h4>
<p>Obtain a copy of the curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <p>copy the control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> pts = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"controlPoints"</span>);

	<span class="hljs-keyword">var</span> pts_copy = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		pts_copy.push( pts[i].slice(<span class="hljs-number">0</span>) );
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> verb.geom.NurbsCurve( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degree'</span>), pts_copy, <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'weights'</span>).slice(<span class="hljs-number">0</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knots'</span>).slice );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              <h4 id="homogenize-">homogenize()</h4>
<p>Obtain the homogeneous representation of the control points</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, 2d array of homogenized control points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.homogenize = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> verb.eval.nurbs.homogenize_1d( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'controlPoints'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'weights'</span>) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <h4 id="update-">update()</h4>
<p>If this is a subtype of the NurbsCurve, this method will update the Nurbs representation
of the curve from those parameters.  This destroys any manual changes to the Nurbs rep.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsCurve.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.nurbsRep ){
		<span class="hljs-keyword">return</span>;
	}

	<span class="hljs-keyword">var</span> curve_props = <span class="hljs-keyword">this</span>.nurbsRep();

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"controlPoints"</span>: curve_props.control_points,
		<span class="hljs-string">"weights"</span>: curve_props.weights,
		<span class="hljs-string">"knots"</span>: curve_props.knots,
		<span class="hljs-string">"degree"</span>: curve_props.degree
	});

};</pre></div></div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <h3 id="new-nurbssurface-degreeu-knotsu-degreev-knotsv-controlpoints-weights-">new NurbsSurface( degreeU, knotsU, degreeV, knotsV, controlPoints, weights )</h3>
<p>Constructor for a NurbsSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The degree of the surface in the u direction</li>
<li><em>Array</em>, Array of numbers representing the knot positions in the u direction</li>
<li><em>Number</em>, The degree of the surface in the v direction</li>
<li><em>Array</em>, Array of numbers representing the knot positions in the v direction</li>
<li><em>Array</em>, 3d array representing the unweighted control points</li>
<li><em>Array</em>, 2d array representing the surface weight structure</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degreeU, knotsU, degreeV, knotsV, controlPoints, weights )</span> {</span>

	verb.geom.NurbsGeometry.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"controlPoints"</span>: controlPoints,
		<span class="hljs-string">"weights"</span>: weights,
		<span class="hljs-string">"knotsU"</span>: knotsU ? knotsU.slice(<span class="hljs-number">0</span>) : [],
		<span class="hljs-string">"knotsV"</span>: knotsV ? knotsV.slice(<span class="hljs-number">0</span>) : [],
		<span class="hljs-string">"degreeU"</span>: degreeU,
		<span class="hljs-string">"degreeV"</span>: degreeV
	});

}.inherits( verb.geom.NurbsGeometry );</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <h4 id="point-u-v-callback-">point( u, v [, callback] )</h4>
<p>Sample a point at the given u, v parameter </p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The u parameter at which to sample</li>
<li><em>Number</em>, The v parameter at which to sample</li>
<li><em>Function</em>, Optional callback to do it async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, v, callback )</span> {</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_surface_point'</span>, 
							[ 	<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>), <span class="hljs-keyword">this</span>.homogenize(), u, v ], callback );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <h4 id="derivatives-u-v-num_derivs-callback-">derivatives( u, v, num_derivs [, callback] )</h4>
<p>Get derivatives at a given u, v parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, The u parameter to sample the curve</li>
<li><em>Number</em>, The v parameter to sample the curve</li>
<li><em>Number</em>, The number of derivatives to obtain</li>
<li><em>Number</em>, The callback, if you want this async</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.derivatives = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, v, num_derivs, callback )</span> {</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'rational_surface_derivs'</span>, 
			[	<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>), <span class="hljs-keyword">this</span>.homogenize(), num_derivs, u, v ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <h4 id="tesselate-options-callback-">tesselate(options [, callback] )</h4>
<p>Tesselate the surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, Tesselate the surface, given an options object includings a vdivs and udivs property</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.tesselate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(options, callback)</span>{</span>

	<span class="hljs-keyword">var</span> minDivsV = <span class="hljs-number">20</span>
		, minDivsU = <span class="hljs-number">20</span>;

	<span class="hljs-keyword">if</span> (options){
		minDivsV = options.minDivsV || minDivsV;
		minDivsU = options.minDivsU || minDivsU;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>naive surface tesselation, for now</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'tesselate_rational_surface_naive'</span>, 
			[	<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>), <span class="hljs-keyword">this</span>.homogenize(), 
			minDivsU, minDivsV ], callback ); 

};</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <h4 id="transform-mat-">transform( mat )</h4>
<p>Transform a curve with the given matrix.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.transform = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mat )</span>{</span>

	<span class="hljs-keyword">var</span> pts = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"controlPoints"</span>);

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; pts[i].length; j++){
			<span class="hljs-keyword">var</span> homoPt = pts[<span class="hljs-number">1</span>].push(<span class="hljs-number">1</span>);
			pts[i] = numeric.mul( mat, homoPt ).slice( <span class="hljs-number">0</span>, homoPt.length-<span class="hljs-number">2</span> );
		}
	}

	<span class="hljs-keyword">this</span>.set(<span class="hljs-string">'controlPoints'</span>, pts);

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <h4 id="clone-">clone()</h4>
<p>Obtain a copy of the curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 4d array representing the transform</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, An array if called synchronously, otherwise nothing</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.clone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>copy the control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> pts = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"controlPoints"</span>);
	<span class="hljs-keyword">var</span> pts_copy = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		pts_copy.push([]);
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; pts[i].length; j++){
			pts_copy[i].push( pts[i][j].slice( <span class="hljs-number">0</span> ) );
		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>copy the weights</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> weights = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"weights"</span>);
	<span class="hljs-keyword">var</span> weights_copy = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; weights.length; i++){
		weights_copy.push( weights[i].slice( <span class="hljs-number">0</span> ) );
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> verb.geom.NurbsSurface( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeU'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsU'</span>).slice(<span class="hljs-number">0</span>), 
		<span class="hljs-keyword">this</span>.get(<span class="hljs-string">'degreeV'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'knotsV'</span>).slice(<span class="hljs-number">0</span>), pts_copy, weights_copy );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <h4 id="homogenize-">homogenize()</h4>
<p>Obtain the homogeneous representation of the control points</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Array</em>, 3d array of homogenized control points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.homogenize = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> verb.eval.nurbs.homogenize_2d( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'controlPoints'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'weights'</span>) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <h4 id="update-">update()</h4>
<p>If this is a subtype of the NurbsSurface, this method will update the Nurbs representation
of the curve from those parameters.  This destroys any manual changes to the Nurbs rep.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.NurbsSurface.prototype.update = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.nurbsRep ){
		<span class="hljs-keyword">return</span>;
	}

	<span class="hljs-keyword">var</span> curve_props = <span class="hljs-keyword">this</span>.nurbsRep();

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"controlPoints"</span>: curve_props.control_points,
		<span class="hljs-string">"weights"</span>: curve_props.weights,
		<span class="hljs-string">"knotsU"</span>: curve_props.knots_u,
		<span class="hljs-string">"knotsV"</span>: curve_props.knots_v,
		<span class="hljs-string">"degreeU"</span>: curve_props.degree_u,
		<span class="hljs-string">"degreeV"</span>: curve_props.degree_v
	});

};</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <h3 id="new-arc-center-xaxis-yaxis-radius-interval-">new Arc(center, xaxis, yaxis, radius, interval)</h3>
<p>Constructor for Arc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the arc</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius of the arc</li>
<li><em>Interval</em>, Interval object representing the interval of the arc</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Arc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(center, xaxis, yaxis, radius, interval)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll( {
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"yaxis"</span>: yaxis,
		<span class="hljs-string">"radius"</span>: radius,
		<span class="hljs-string">"interval"</span>: interval 
	});

	<span class="hljs-keyword">this</span>.update();
	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'yaxis'</span>, <span class="hljs-string">'radius'</span>, <span class="hljs-string">'interval'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Arc.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_arc'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yaxis"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"interval"</span>).get(<span class="hljs-string">"min"</span>), 
													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"interval"</span>).get(<span class="hljs-string">"max"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <h3 id="new-beziercurve-control_points-weights-">new BezierCurve( control_points [, weights] )</h3>
<p>Constructor for BezierCurve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of Length 3 arrays representing the control pts of the bezier curve</li>
<li><em>Array</em>, Array of numbers representing the weights of the bezier curve, omit if you don&#39;t want this to be a rational curve</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BezierCurve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( control_points, weights )</span> {</span>

	verb.geom.NurbsCurve.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll( {
		<span class="hljs-string">"controlPoints"</span>: control_points ? control_points.slice(<span class="hljs-number">0</span>) : [],
		<span class="hljs-string">"weights"</span>: weights ? weights.slice(<span class="hljs-number">0</span>) : <span class="hljs-literal">undefined</span>
	});

	<span class="hljs-keyword">this</span>.update();

}.inherits( verb.geom.NurbsCurve );</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BezierCurve.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">var</span> control_points = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'controlPoints'</span>);
	<span class="hljs-keyword">var</span> weights = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'weights'</span>);
	<span class="hljs-keyword">var</span> degree = control_points.length - <span class="hljs-number">1</span>;

	<span class="hljs-keyword">var</span> knots = [];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; degree + <span class="hljs-number">1</span>; i++){ knots.push(<span class="hljs-number">0</span>); }
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; degree + <span class="hljs-number">1</span>; i++){ knots.push(<span class="hljs-number">1</span>); }</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>if weights aren&#39;t provided, build uniform weights</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (weights === <span class="hljs-literal">undefined</span>){
		weights = [];
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; control_points.length; i++){
			weights.push(<span class="hljs-number">1</span>);
		}
	}

	<span class="hljs-keyword">return</span> {
		degree: degree,
		knots: knots, 
		control_points: control_points,
		weights: weights
	};

};</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <h3 id="new-boundingbox-points-">new BoundingBox([ points ])</h3>
<p>BoundingBox Constructor</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Points to add, if desired.  Otherwise, will not be initialized until add is called.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
	<span class="hljs-keyword">this</span>.initialized = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">this</span>.min = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];
	<span class="hljs-keyword">this</span>.max = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];

 	<span class="hljs-keyword">var</span> pt_args = <span class="hljs-built_in">Array</span>.prototype.slice.call( <span class="hljs-built_in">arguments</span>, <span class="hljs-number">0</span>);

 	<span class="hljs-keyword">if</span> (pt_args.length === <span class="hljs-number">1</span> &amp;&amp; pt_args[<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> &amp;&amp; pt_args[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span> ){
 		<span class="hljs-keyword">this</span>.add_elements_sync(pt_args[<span class="hljs-number">0</span>]);
 	} <span class="hljs-keyword">else</span> {
 		<span class="hljs-keyword">this</span>.add_elements_sync(pt_args);
 	}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <h4 id="add_elements-point_array-callback-">add_elements( point_array, callback )</h4>
<p>Asynchronously add an array of points to the bounding box</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, An array of length-3 array of numbers </li>
<li><em>Function</em>, Function to call when all of the points in array have been added.  The only parameter to this
callback is this bounding box.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.add_elements = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( point_array, callback )</span> 
{</span>

	<span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>; 
	setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>
		point_array.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem, index)</span> {</span>
			that.add(elem);
		});
		callback(that);
	}, <span class="hljs-number">0</span>);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <h4 id="add_elements_sync-point_array-">add_elements_sync( point_array )</h4>
<p>Synchronously add an array of points to the bounding box</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, An array of length-3 array of numbers </li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, This BoundingBox for chaining</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.add_elements_sync = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( point_array )</span> 
{</span>
	<span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>; 
	point_array.forEach( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(elem)</span> {</span>
		that.add(elem);
	});
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <h4 id="add-point-">add( point )</h4>
<p>Adds a point to the bounding box, expanding the bounding box if the point is outside of it.
If the bounding box is not initialized, this method has that side effect.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, A length-3 array of numbers </li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, This BoundingBox for chaining</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.add = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( point )</span> 
{</span>
	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.initialized )
	{
		<span class="hljs-keyword">this</span>.min = point.slice(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">this</span>.max = point.slice(<span class="hljs-number">0</span>);
		<span class="hljs-keyword">this</span>.initialized = <span class="hljs-literal">true</span>;
		<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
	}

	<span class="hljs-keyword">if</span> (point[<span class="hljs-number">0</span>] &gt; <span class="hljs-keyword">this</span>.max[<span class="hljs-number">0</span>] )
	{
		<span class="hljs-keyword">this</span>.max[<span class="hljs-number">0</span>] = point[<span class="hljs-number">0</span>];
	}

	<span class="hljs-keyword">if</span> (point[<span class="hljs-number">1</span>] &gt; <span class="hljs-keyword">this</span>.max[<span class="hljs-number">1</span>] )
	{
		<span class="hljs-keyword">this</span>.max[<span class="hljs-number">1</span>] = point[<span class="hljs-number">1</span>];
	}

	<span class="hljs-keyword">if</span> (point[<span class="hljs-number">2</span>] &gt; <span class="hljs-keyword">this</span>.max[<span class="hljs-number">2</span>] )
	{
		<span class="hljs-keyword">this</span>.max[<span class="hljs-number">2</span>] = point[<span class="hljs-number">2</span>];
	}

	<span class="hljs-keyword">if</span> (point[<span class="hljs-number">0</span>] &lt; <span class="hljs-keyword">this</span>.min[<span class="hljs-number">0</span>] )
	{
		<span class="hljs-keyword">this</span>.min[<span class="hljs-number">0</span>] = point[<span class="hljs-number">0</span>];
	}

	<span class="hljs-keyword">if</span> (point[<span class="hljs-number">1</span>] &lt; <span class="hljs-keyword">this</span>.min[<span class="hljs-number">1</span>] )
	{
		<span class="hljs-keyword">this</span>.min[<span class="hljs-number">1</span>] = point[<span class="hljs-number">1</span>];
	}

	<span class="hljs-keyword">if</span> (point[<span class="hljs-number">2</span>] &lt; <span class="hljs-keyword">this</span>.min[<span class="hljs-number">2</span>] )
	{
		<span class="hljs-keyword">this</span>.min[<span class="hljs-number">2</span>] = point[<span class="hljs-number">2</span>];
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <h4 id="contains-point-">contains( point )</h4>
<p>Determines if two intervals on the real number line intersect</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Beginning of first interval</li>
<li><em>Number</em>, End of first interval</li>
<li><em>Number</em>, Beginning of second interval</li>
<li><em>Number</em>, End of second interval</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Boolean</em>, true if the two intervals overlap, otherwise false</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.contains = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(point, tol)</span> {</span>

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.initialized )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.intersects( <span class="hljs-keyword">new</span> verb.geom.BoundingBox(point), tol );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <h4 id="tolerance">TOLERANCE</h4>
<p>Defines the tolerance for bounding box operations</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.TOLERANCE = <span class="hljs-number">1e-4</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <h4 id="intervals_overlap-a1-a2-b1-b2-">intervals_overlap( a1, a2, b1, b2 )</h4>
<p>Determines if two intervals on the real number line intersect</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Beginning of first interval</li>
<li><em>Number</em>, End of first interval</li>
<li><em>Number</em>, Beginning of second interval</li>
<li><em>Number</em>, End of second interval</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Boolean</em>, true if the two intervals overlap, otherwise false</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.intervals_overlap = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( a1, a2, b1, b2, tol )</span> {</span>

	<span class="hljs-keyword">var</span> tol = tol || verb.geom.BoundingBox.prototype.TOLERANCE
		, x1 = <span class="hljs-built_in">Math</span>.min(a1, a2) - tol
		, x2 = <span class="hljs-built_in">Math</span>.max(a1, a2) + tol
		, y1 = <span class="hljs-built_in">Math</span>.min(b1, b2) - tol
		, y2 = <span class="hljs-built_in">Math</span>.max(b1, b2) + tol;

	<span class="hljs-keyword">if</span> ( (x1 &gt;= y1 &amp;&amp; x1 &lt;= y2) || (x2 &gt;= y1 &amp;&amp; x2 &lt;= y2) || (y1 &gt;= x1 &amp;&amp; y1 &lt;= x2) || (y2 &gt;= x1 &amp;&amp; y2 &lt;= x2) )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}
	<span class="hljs-keyword">else</span> 
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}

}</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <h4 id="intersects-bb-">intersects( bb )</h4>
<p>Determines if this bounding box intersects with another</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, BoundingBox to check for intersection with this one</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Boolean</em>, true if the two bounding boxes intersect, otherwise false</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.intersects = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( bb, tol )</span> {</span>

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.initialized || !bb.initialized )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
	}

	<span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">this</span>.min
		, a2 = <span class="hljs-keyword">this</span>.max
		, b1 = bb.min
		, b2 = bb.max;

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.intervals_overlap(a1[<span class="hljs-number">0</span>], a2[<span class="hljs-number">0</span>], b1[<span class="hljs-number">0</span>], b2[<span class="hljs-number">0</span>], tol ) 
			&amp;&amp; <span class="hljs-keyword">this</span>.intervals_overlap(a1[<span class="hljs-number">1</span>], a2[<span class="hljs-number">1</span>], b1[<span class="hljs-number">1</span>], b2[<span class="hljs-number">1</span>], tol ) 
			&amp;&amp; <span class="hljs-keyword">this</span>.intervals_overlap(a1[<span class="hljs-number">2</span>], a2[<span class="hljs-number">2</span>], b1[<span class="hljs-number">2</span>], b2[<span class="hljs-number">2</span>], tol ) )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}

	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <h4 id="clear-bb-">clear( bb )</h4>
<p>Clear the bounding box, leaving it in an uninitialized state.  Call add, add_elements in order to 
initialize</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, this BoundingBox for chaining</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.clear = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( bb )</span> {</span>

	<span class="hljs-keyword">this</span>.initialized = <span class="hljs-literal">false</span>;
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <h4 id="get_longest_axis-bb-">get_longest_axis( bb )</h4>
<p>Get longest axis of bounding box</p>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, Index of longest axis</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.get_longest_axis = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( bb )</span> {</span>

	<span class="hljs-keyword">var</span> axis_lengths = [ 	<span class="hljs-keyword">this</span>.get_axis_length(<span class="hljs-number">0</span>), 
							<span class="hljs-keyword">this</span>.get_axis_length(<span class="hljs-number">1</span>), 
							<span class="hljs-keyword">this</span>.get_axis_length(<span class="hljs-number">2</span>)];

	<span class="hljs-keyword">return</span> axis_lengths.indexOf(<span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-built_in">Math</span>, axis_lengths));

};</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <h4 id="get_axis_length-i-">get_axis_length( i )</h4>
<p>Get length of given axis. </p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Index of axis to inspect (between 0 and 2)</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Number</em>, Length of the given axis.  If axis is out of bounds, returns 0.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.get_axis_length = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( i )</span> {</span>

	<span class="hljs-keyword">if</span> (i &lt; <span class="hljs-number">0</span> || i &gt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.abs( <span class="hljs-keyword">this</span>.min[i] - <span class="hljs-keyword">this</span>.max[i] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <h4 id="intersect-bb-">intersect( bb )</h4>
<p>Compute the boolean intersection of this with another axis-aligned bounding box.  If the two
bounding boxes do not intersect, returns null.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Object</em>, BoundingBox to intersect with</li>
</ul>
<p><strong>returns</strong></p>
<ul>
<li><em>Object</em>, The bounding box formed by the intersection or null if there is no intersection.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.BoundingBox.prototype.intersect = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( bb, tol )</span> {</span>

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.initialized )
	{
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> a1 = <span class="hljs-keyword">this</span>.min
		, a2 = <span class="hljs-keyword">this</span>.max
		, b1 = bb.min
		, b2 = bb.max;

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.intersects( bb, tol ) )
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

	<span class="hljs-keyword">var</span> xmax = <span class="hljs-built_in">Math</span>.min( a2[<span class="hljs-number">0</span>], b2[<span class="hljs-number">0</span>] )
		, xmin = <span class="hljs-built_in">Math</span>.max( a1[<span class="hljs-number">0</span>], b1[<span class="hljs-number">0</span>] )
		, ymax = <span class="hljs-built_in">Math</span>.min( a2[<span class="hljs-number">1</span>], b2[<span class="hljs-number">1</span>] )
		, ymin = <span class="hljs-built_in">Math</span>.max( a1[<span class="hljs-number">1</span>], b1[<span class="hljs-number">1</span>] )
		, zmax = <span class="hljs-built_in">Math</span>.min( a2[<span class="hljs-number">2</span>], b2[<span class="hljs-number">2</span>] )
		, zmin = <span class="hljs-built_in">Math</span>.max( a1[<span class="hljs-number">2</span>], b1[<span class="hljs-number">2</span>] )
		, max_bb = [ xmax, ymax, zmax]
		, min_bb = [ xmin, ymin, zmin];

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> verb.geom.BoundingBox(min_bb, max_bb);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <h3 id="new-circle-center-xaxis-yaxis-xradius-yradius-">new Circle(center, xaxis, yaxis, xradius, yradius)</h3>
<p>Constructor for Circle</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the circle</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Circle = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(center, xaxis, yaxis, radius)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"yaxis"</span>: yaxis,
		<span class="hljs-string">"radius"</span>: radius 
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'yaxis'</span>, <span class="hljs-string">'radius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Circle.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_arc'</span>, [  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
																									 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
																									 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yaxis"</span>), 
																									 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>), 
																									 <span class="hljs-number">0</span>, 
																									 <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <h3 id="new-cone-axis-xaxis-base-height-radius-">new Cone(axis, xaxis, base, height, radius )</h3>
<p>Constructor for Cone</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the axis of the cone</li>
<li><em>Array</em>, Length 3 array representing the x axis, perpendicular to the axis</li>
<li><em>Array</em>, Length 3 array representing the base of the cone</li>
<li><em>Number</em>, Height of the cone</li>
<li><em>Number</em>, Radius of the cone</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Cone = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(axis, xaxis, base, height, radius )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"axis"</span>: axis,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"base"</span>: base,
		<span class="hljs-string">"height"</span>: height,
		<span class="hljs-string">"radius"</span>: radius 
	});

	<span class="hljs-keyword">var</span> surface_props = <span class="hljs-keyword">this</span>.nurbsRep();

	verb.geom.NurbsSurface.call(<span class="hljs-keyword">this</span>, surface_props.degree_u, surface_props.knots_u, surface_props.degree_v, surface_props.knots_v, surface_props.control_points, surface_props.weights );

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'axis'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'base'</span>, <span class="hljs-string">'height'</span>, <span class="hljs-string">'radius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Cone.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_cone_surface'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"axis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"base"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"height"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <h3 id="new-cylinder-center-xaxis-yaxis-xradius-yradius-">new Cylinder(center, xaxis, yaxis, xradius, yradius)</h3>
<p>Constructor for Cylinder</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the axis of the cylinder</li>
<li><em>Array</em>, Length 3 array representing the x axis, perpendicular to the axis</li>
<li><em>Array</em>, Length 3 array representing the base of the cylinder</li>
<li><em>Number</em>, Height of the cylinder</li>
<li><em>Number</em>, Radius of the cylinder</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Cylinder = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(axis, xaxis, base, height, radius )</span> {</span>

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"axis"</span>: axis,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"base"</span>: base,
		<span class="hljs-string">"height"</span>: height,
		<span class="hljs-string">"radius"</span>: radius 
	});

	<span class="hljs-keyword">var</span> surface_props = <span class="hljs-keyword">this</span>.nurbsRep();

	verb.geom.NurbsSurface.call(<span class="hljs-keyword">this</span>, surface_props.degree_u, surface_props.knots_u, surface_props.degree_v, surface_props.knots_v, surface_props.control_points, surface_props.weights );

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'axis'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'base'</span>, <span class="hljs-string">'height'</span>, <span class="hljs-string">'radius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Cylinder.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_cylinder_surface'</span>, 
						  												 [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"axis"</span>), 
						  												 	 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
						  													 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"base"</span>), 
																				 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"height"</span>), 
																				 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <h3 id="new-ellipse-center-xaxis-yaxis-xradius-yradius-">new Ellipse(center, xaxis, yaxis, xradius, yradius)</h3>
<p>Constructor for EllipseArc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the arc</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius of the arc in the x direction</li>
<li><em>Number</em>, Radius of the arc in the y direction</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Ellipse = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(center, xaxis, yaxis, xradius, yradius)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"yaxis"</span>: yaxis,
		<span class="hljs-string">"xradius"</span>: xradius,
		<span class="hljs-string">"yradius"</span>: yradius
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'yaxis'</span>, <span class="hljs-string">'xradius'</span>, <span class="hljs-string">'yradius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Ellipse.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_ellipse_arc'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xradius"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yradius"</span>), 
															 <span class="hljs-number">0</span>, 
															 <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <h3 id="new-ellipsearc-center-xaxis-yaxis-xradius-yradius-interval-">new EllipseArc(center, xaxis, yaxis, xradius, yradius, interval)</h3>
<p>Constructor for EllipseArc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center of the arc</li>
<li><em>Array</em>, Length 3 array representing the xaxis</li>
<li><em>Array</em>, Length 3 array representing the perpendicular yaxis</li>
<li><em>Number</em>, Radius of the arc in the x direction</li>
<li><em>Number</em>, Radius of the arc in the y direction</li>
<li><em>Interval</em>, Interval object representing the interval of the arc</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.EllipseArc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(center, xaxis, yaxis, xradius, yradius, interval)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"xaxis"</span>: xaxis,
		<span class="hljs-string">"yaxis"</span>: yaxis,
		<span class="hljs-string">"xradius"</span>: xradius,
		<span class="hljs-string">"yradius"</span>: yradius,
		<span class="hljs-string">"interval"</span>: interval
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'xaxis'</span>, <span class="hljs-string">'yaxis'</span>, <span class="hljs-string">'xradius'</span>, <span class="hljs-string">'yradius'</span>, <span class="hljs-string">'interval'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.EllipseArc.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_ellipse_arc'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yaxis"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"xradius"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"yradius"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"interval"</span>).get(<span class="hljs-string">"min"</span>), 
													 		 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"interval"</span>).get(<span class="hljs-string">"max"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <h3 id="new-extrusion-p1-p2-p3-pt-">new Extrusion(p1, p2, p3, pt)</h3>
<p>Constructor for Extrusion</p>
<p><strong>params</strong></p>
<ul>
<li><em>NurbsCurve</em>, The curve to extrude</li>
<li><em>Array</em>, Length 3 representing the direction to extrude</li>
<li><em>Number</em>, The distance to extrude</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Extrusion = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(profile, axis, length )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({ 
		  <span class="hljs-string">"profile"</span>: profile,
		  <span class="hljs-string">"axis"</span>: axis,
	      <span class="hljs-string">"length"</span>: length 
	  });

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'axis'</span>, <span class="hljs-string">'length'</span> ], <span class="hljs-keyword">this</span>.update );
	profile.watchAll( [<span class="hljs-string">'knots'</span>, <span class="hljs-string">'degree'</span>, <span class="hljs-string">'controlPoints'</span>, <span class="hljs-string">'weights'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Extrusion.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span> {</span>

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_extruded_surface'</span>, 
									[ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"axis"</span>), 
								 	  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"length"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"knots"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"degree"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"controlPoints"</span>),
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"weights"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <h3 id="new-fourpointsurface-p1-p2-p3-pt-">new FourPointSurface(p1, p2, p3, pt)</h3>
<p>Constructor for FourPointSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the first position in ccw direction</li>
<li><em>Array</em>, Length 3 array representing the second position in ccw direction</li>
<li><em>Array</em>, Length 3 array representing the third position in ccw direction</li>
<li><em>Array</em>, Length 3 array representing the fourth position in ccw direction, repeat the third position to get a triangle</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.FourPointSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(p1, p2, p3, p4)</span> {</span>

	verb.geom.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll( {
		<span class="hljs-string">"p1"</span>: p1,
		<span class="hljs-string">"p2"</span>: p2,
		<span class="hljs-string">"p3"</span>: p3,
		<span class="hljs-string">"p4"</span>: p4
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'p1'</span>, <span class="hljs-string">'p2'</span>, <span class="hljs-string">'p3'</span>, <span class="hljs-string">'p4'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.FourPointSurface.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_4pt_surface'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"p1"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"p2"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"p3"</span>), 
															 <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"p4"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <h3 id="new-interval-min-max-">new Interval(min, max)</h3>
<p>Constructor for Interval</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Start of interval </li>
<li><em>Number</em>, End of the interval </li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Interval = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(min, max)</span> {</span>

	verb.core.WatchObject.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll({ 
		<span class="hljs-string">"min"</span>: min,
		<span class="hljs-string">"max"</span>: max 
	});

}.inherits(verb.core.WatchObject);</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <h3 id="new-interval2-minu-maxu-minv-maxv-">new Interval2(minu, maxu, minv, maxv)</h3>
<p>Constructor for Interval2</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, Start of interval in the u direction</li>
<li><em>Number</em>, End of the interval in the u direction</li>
<li><em>Number</em>, Start of interval in the v direction</li>
<li><em>Number</em>, End of the interval in the v direction</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Interval2 = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(minu, maxu, minv, maxv)</span> {</span>

	verb.core.WatchObject.call(<span class="hljs-keyword">this</span>);
	
	<span class="hljs-keyword">this</span>.setAll({ 
		<span class="hljs-string">"uinterval"</span>: <span class="hljs-keyword">new</span> verb.geom.Interval(minu, maxu),
		<span class="hljs-string">"vinterval"</span>: <span class="hljs-keyword">new</span> verb.geom.Interval(minv, maxv)
	});

}.inherits(verb.core.WatchObject);</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h3 id="new-line-start-end-">new Line(start, end)</h3>
<p>Constructor for a Line</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the start point</li>
<li><em>Array</em>, Length 3 array representing the end point</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Line = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(start, end)</span> {</span>

	verb.geom.NurbsCurve.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({ 
		<span class="hljs-string">"start"</span>: start,
		<span class="hljs-string">"end"</span>: end
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll([<span class="hljs-string">'start'</span>, <span class="hljs-string">'end'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Line.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> {
			knots: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], 
			control_points: [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"start"</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"end"</span>) ],
			weights: [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>],
			degree: <span class="hljs-number">1</span>
	};

};</pre></div></div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <h3 id="new-planarsurface-base-uaxis-vaxis-ulength-vlength-">new PlanarSurface( base, uaxis, vaxis, ulength, vlength )</h3>
<p>Constructor for PlanarSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the base point</li>
<li><em>Array</em>, Length 3 array representing the uaxis, defines the one axis of the planar surface</li>
<li><em>Array</em>, Length 3 array representing the vaxis, defines the one second axis of the planar surface</li>
<li><em>Number</em>, Length in the u direction </li>
<li><em>Number</em>, Length in the v direction</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.PlanarSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( base, uaxis, vaxis, ulength, vlength )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"base"</span>: base,
		<span class="hljs-string">"uaxis"</span>: uaxis,
		<span class="hljs-string">"vaxis"</span>: vaxis,
		<span class="hljs-string">"ulength"</span>: ulength,
		<span class="hljs-string">"vlength"</span>: vlength
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'base'</span>, <span class="hljs-string">'uaxis'</span>, <span class="hljs-string">'vaxis'</span>, <span class="hljs-string">'ulength'</span>, <span class="hljs-string">'vlength'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.PlanarSurface.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'base'</span>)
		, uedge = numeric.mul( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'uaxis'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'ulength'</span>))
		, vedge = numeric.mul( <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'vaxis'</span>), <span class="hljs-keyword">this</span>.get(<span class="hljs-string">'vlength'</span>))
		, p2 = numeric.add( p1, uedge )
		, p3 = numeric.add( p1, vedge, uedge )
		, p4 = numeric.add( p1, vedge );

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_4pt_surface'</span>, [ p1, p2, p3, p4 ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <h3 id="new-polyline-points-">new PolyLine( points )</h3>
<p>Constructor for a PolyLine</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Array of length-3 arrays representing the points</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.PolyLine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points )</span> {</span>

	verb.geom.NurbsCurve.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll( {
		<span class="hljs-string">"control_points"</span>: points ? points.slice(<span class="hljs-number">0</span>) : []
	});

	<span class="hljs-keyword">this</span>.update();

}.inherits(verb.geom.NurbsCurve);</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.PolyLine.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_polyline_curve'</span>, [ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"control_points"</span>) ]);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <h3 id="new-revolvedsurface-points-">new RevolvedSurface( points )</h3>
<p>Constructor for a RevolvedSurface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing a point on the revolve axis</li>
<li><em>Array</em>, The axis of the revolve</li>
<li><em>Array</em>, The angle to revolve on</li>
<li><em>NurbsCurve</em>, The curve to revolve</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.RevolvedSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, axis, angle, profile )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"axis"</span>: axis,
		<span class="hljs-string">"angle"</span>: angle,
		<span class="hljs-string">"profile"</span>: profile
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'axis'</span>, <span class="hljs-string">'angle'</span>, <span class="hljs-string">'profile'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.RevolvedSurface.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

	  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_revolved_surface'</span>, 
									[ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"axis"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"angle"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"knots"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"degree"</span>), 
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"controlPoints"</span>),
									  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"weights"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <h3 id="new-sphere-center-radius-">new Sphere( center, radius )</h3>
<p>Constructor for a Sphere</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, Length 3 array representing the center</li>
<li><em>Number</em>, Radius of the sphere</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Sphere = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, radius )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"center"</span>: center,
		<span class="hljs-string">"radius"</span>: radius
	});

	<span class="hljs-keyword">this</span>.update();
	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'center'</span>, <span class="hljs-string">'radius'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.Sphere.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>

  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_sphere_surface'</span>, 
										[ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"center"</span>), 
										  [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>],
										  [<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>],
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"radius"</span>)] );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <h3 id="new-sweeponerail-rail-profile-">new SweepOneRail( rail, profile )</h3>
<p>Constructor for a SweepOneRail</p>
<p><strong>params</strong></p>
<ul>
<li><em>NurbsCurve</em>, The path to sweep on</li>
<li><em>NurbsCurve</em>, The profile to sweep</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.SweepOneRail = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( rail, profile )</span> {</span>

	verb.geom.NurbsSurface.call(<span class="hljs-keyword">this</span>);

	<span class="hljs-keyword">this</span>.setAll({
		<span class="hljs-string">"rail"</span>: rail,
		<span class="hljs-string">"profile"</span>: profile
	});

	<span class="hljs-keyword">this</span>.update();

	<span class="hljs-keyword">this</span>.watchAll( [<span class="hljs-string">'rail'</span>, <span class="hljs-string">'profile'</span>], <span class="hljs-keyword">this</span>.update );

}.inherits(verb.geom.NurbsSurface);</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <h4 id="nurbsrep-">nurbsRep()</h4>
<p>Construct the Nurbs representation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.geom.SweepOneRail.prototype.nurbsRep = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
	
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.nurbsEngine.eval( <span class="hljs-string">'get_sweep1_surface'</span>, 
										[ <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"knots"</span>), 
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"degree"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"controlPoints"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"profile"</span>).get(<span class="hljs-string">"weights"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"rail"</span>).get(<span class="hljs-string">"knots"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"rail"</span>).get(<span class="hljs-string">"degree"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"rail"</span>).get(<span class="hljs-string">"controlPoints"</span>),
										  <span class="hljs-keyword">this</span>.get(<span class="hljs-string">"rail"</span>).get(<span class="hljs-string">"weights"</span>)] );

};
verb.intersect.curveCurve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( curve1, curve2, callback )</span>{</span>

	<span class="hljs-keyword">return</span> verb.nurbsEngine.eval( <span class="hljs-string">'intersect_rational_curves_by_aabb_refine'</span>, 
							[ 	curve1.get(<span class="hljs-string">'degree'</span>), curve1.get(<span class="hljs-string">'knots'</span>), curve1.homogenize(), 
							curve2.get(<span class="hljs-string">'degree'</span>), curve2.get(<span class="hljs-string">'knots'</span>), 
							curve2.homogenize(), verb.TOLERANCE, verb.TOLERANCE ], callback );
}
verb.intersect.curveSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( curve, surface, options, callback )</span>{</span>

	options = options || { tolerance: verb.TOLERANCE, sampleTolerance: verb.TOLERANCE, uDivs: <span class="hljs-number">20</span>, vDivs: <span class="hljs-number">20</span> };

	<span class="hljs-keyword">return</span> verb.nurbsEngine.eval( <span class="hljs-string">'intersect_rational_curve_surface_by_aabb_refine'</span>, 
																[ surface.get(<span class="hljs-string">'degreeU'</span>), 
																	surface.get(<span class="hljs-string">'knotsU'</span>), 
																	surface.get(<span class="hljs-string">'degreeV'</span>), 
																	surface.get(<span class="hljs-string">'knotsV'</span>), 
																	surface.homogenize(), 
																	curve.get(<span class="hljs-string">'degree'</span>), 
																	curve.get(<span class="hljs-string">'knots'</span>), 
																	curve.homogenize(), 
																	options.sampleTolerance, 
																	options.tolerance, 
																	options.uDivs,
																	options.vDivs ], callback );
};</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <h4 id="intersect_rational_curve_surface_by_aabb-degree_u-knots_u-degree_v-knots_v-homo_control_points-degree_crv-knots_crv-homo_control_points_crv-sample_tol-tol-">intersect_rational_curve_surface_by_aabb( degree_u, knots_u, degree_v, knots_v, homo_control_points, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol )</h4>
<p>Get the intersection of a NURBS curve and a NURBS surface by axis-aligned bounding box intersection and refinement</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of homogeneous control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi)</li>
<li><em>Number</em>, the sample tolerance of the curve</li>
<li><em>Number</em>, tolerance for the curve intersection</li>
<li><em>Number</em>, integer number of divisions of the surface in the U direction for initial approximation (placeholder until adaptive tess of surfaces)</li>
<li><em>Number</em>, integer number of divisions of the surface in the V direction for initial approximation (placeholder until adaptive tess of surfaces)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of intersection objects, each holding:<ul>
<li>a &quot;point&quot; property where intersections took place</li>
<li>a &quot;p&quot; the parameter on the curve</li>
</ul>
</li>
<li>a &quot;uv&quot; the parameter on the surface<ul>
<li>a &quot;face&quot; the index of the face where the intersection took place</li>
</ul>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.intersect_rational_curve_surface_by_aabb_refine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol, divs_u, divs_v )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>get the approximate intersections</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> ints = verb.eval.nurbs.intersect_rational_curve_surface_by_aabb( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol, divs_u, divs_v );</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>refine them</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> ints.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( inter )</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>get intersection params</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> start_params = [inter.p, inter.uv[<span class="hljs-number">0</span>], inter.uv[<span class="hljs-number">1</span>] ]</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>refine the parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, refined_params = verb.eval.nurbs.refine_rational_curve_surface_intersection( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, start_params );</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>update the inter object</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		inter.p = refined_params[<span class="hljs-number">0</span>];
		inter.uv[<span class="hljs-number">0</span>] = refined_params[<span class="hljs-number">1</span>];
		inter.uv[<span class="hljs-number">1</span>] = refined_params[<span class="hljs-number">2</span>];
		inter.distance = refined_params[<span class="hljs-number">3</span>];
		<span class="hljs-keyword">delete</span> inter.face;

		<span class="hljs-keyword">return</span> inter;

	});

}</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <h4 id="refine_rational_curve_surface_intersection-degree_u-knots_u-degree_v-knots_v-homo_control_points_srf-degree_crv-knots_crv-homo_control_points_crv-start_params-">refine_rational_curve_surface_intersection( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, start_params )</h4>
<p>Refine an intersection pair for a surface and curve given an initial guess.  This is an unconstrained minimization,
so the caller is responsible for providing a very good initial guess.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of homogeneous control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi)</li>
<li><em>Array</em>, array of initial parameter values [ u_crv, u_srf, v_srf ]</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a length 3 array containing the [ u_crv, u_srf, v_srf, final_distance ]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.refine_rational_curve_surface_intersection = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, start_params )</span> {</span>

	<span class="hljs-keyword">var</span> objective = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> {</span> 

		<span class="hljs-keyword">var</span> p1 = verb.eval.nurbs.rational_curve_point(degree_crv, knots_crv, homo_control_points_crv, x[<span class="hljs-number">0</span>])
			, p2 = verb.eval.nurbs.rational_surface_point( degree_u, knots_u,  degree_v, knots_v, homo_control_points_srf, x[<span class="hljs-number">1</span>], x[<span class="hljs-number">2</span>] )
			, p1_p2 = numeric.sub(p1, p2);

		<span class="hljs-keyword">return</span> numeric.dot(p1_p2, p1_p2);
	}

	<span class="hljs-keyword">var</span> sol_obj = numeric.uncmin( objective, start_params);
	<span class="hljs-keyword">return</span> sol_obj.solution.concat( sol_obj.f );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <h4 id="intersect_rational_curve_surface_by_aabb-degree_u-knots_u-degree_v-knots_v-homo_control_points-degree_crv-knots_crv-homo_control_points_crv-sample_tol-tol-">intersect_rational_curve_surface_by_aabb( degree_u, knots_u, degree_v, knots_v, homo_control_points, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol )</h4>
<p>Approximate the intersection of two nurbs surface by axis-aligned bounding box intersection.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of homogeneous control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi)</li>
<li><em>Array</em>, array of initial parameter values [ u_crv, u_srf, v_srf ]</li>
<li><em>Number</em>, the sample tolerance of the curve</li>
<li><em>Number</em>, tolerance for the curve intersection</li>
<li><em>Number</em>, integer number of divisions of the surface in the U direction</li>
<li><em>Number</em>, integer number of divisions of the surface in the V direction</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of intersection objects, each holding:<ul>
<li>a &quot;point&quot; property where intersections took place</li>
<li>a &quot;p&quot; the parameter on the polyline</li>
</ul>
</li>
<li>a &quot;uv&quot; the parameter on the mesh<ul>
<li>a &quot;face&quot; the index of the face where the intersection took place</li>
</ul>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.intersect_rational_curve_surface_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, degree_crv, knots_crv, homo_control_points_crv, sample_tol, tol, divs_u, divs_v )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>tesselate the curve</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> crv = verb.eval.nurbs.rational_curve_adaptive_sample( degree_crv, knots_crv, homo_control_points_crv, sample_tol, <span class="hljs-literal">true</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>tesselate the surface</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		, mesh = verb.eval.nurbs.tesselate_rational_surface_naive( degree_u, knots_u, degree_v, knots_v, homo_control_points_srf, divs_u, divs_v )</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>separate parameters from points in the polyline (params are the first index in the array)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		, u1 = crv.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> {</span> <span class="hljs-keyword">return</span> el[<span class="hljs-number">0</span>]; })
		, p1 = crv.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> {</span> <span class="hljs-keyword">return</span> el.slice(<span class="hljs-number">1</span>) })</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>perform intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		, res = verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb( p1, u1, mesh, verb.range(mesh.faces.length), tol );</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>eliminate duplicate intersections</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> verb.unique( res, <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a, b)</span>{</span>
		<span class="hljs-keyword">return</span> numeric.norm2( numeric.sub( a.point, b.point ) ) &lt; tol &amp;&amp; <span class="hljs-built_in">Math</span>.abs( a.p - b.p ) &lt; tol &amp;&amp; numeric.norm2( numeric.sub( a.uv, b.uv ) ) &lt; tol
	});

}</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <h4 id="intersect_parametric_polyline_mesh_by_aabb-crv_points-crv_param_points-mesh-included_faces-tol-">intersect_parametric_polyline_mesh_by_aabb( crv_points, crv_param_points, mesh, included_faces, tol )</h4>
<p>Approximate the intersection of a polyline and mesh while maintaining parameter information</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of 3d points on the curve</li>
<li><em>Array</em>, array of parameters corresponding to the parameters on the curve</li>
<li><em>Object</em>, a triangular mesh with a &quot;faces&quot; attribute and &quot;points&quot; attribute</li>
<li><em>Array</em>, an array of indices, representing the faces to include in the intersection operation</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of intersection objects (with potential duplicates ) each holding:<ul>
<li>a &quot;point&quot; property where intersections took place</li>
<li>a &quot;p&quot; the parameter on the polyline</li>
</ul>
</li>
<li>a &quot;uv&quot; the parameter on the mesh<ul>
<li>a &quot;face&quot; the index of the face where the intersection took place</li>
</ul>
</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( crv_points, crv_param_points, mesh, included_faces, tol )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>check if two bounding boxes intersect</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> pl_bb = <span class="hljs-keyword">new</span> verb.geom.BoundingBox( crv_points )
		, mesh_bb = verb.eval.mesh.make_mesh_aabb( mesh.points, mesh.faces, included_faces );</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>if bounding boxes do not intersect, return empty array</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( !pl_bb.intersects( mesh_bb, tol ) ) {
		<span class="hljs-keyword">return</span> [];
	}

	<span class="hljs-keyword">if</span> ( crv_points.length === <span class="hljs-number">2</span> &amp;&amp; included_faces.length === <span class="hljs-number">1</span> ){</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>intersect segment and triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> inter = verb.eval.geom.intersect_segment_with_tri( crv_points[<span class="hljs-number">0</span>], crv_points[<span class="hljs-number">1</span>], mesh.points, mesh.faces[ included_faces[<span class="hljs-number">0</span>] ] );

			<span class="hljs-keyword">if</span> ( inter != <span class="hljs-literal">null</span> ){</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>map the parameters of the segment to the parametric space of the entire polyline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			 	<span class="hljs-keyword">var</span> p = inter.p * ( crv_param_points[<span class="hljs-number">1</span>]-crv_param_points[<span class="hljs-number">0</span>] ) + crv_param_points[<span class="hljs-number">0</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>map the parameters of the single triangle to the entire parametric space of the triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			 	<span class="hljs-keyword">var</span> index_v0 = mesh.faces[ included_faces ][<span class="hljs-number">0</span>]
			 		, index_v1 = mesh.faces[ included_faces ][<span class="hljs-number">1</span>]
			 		, index_v2 = mesh.faces[ included_faces ][<span class="hljs-number">2</span>]
			 		, uv_v0 = mesh.uvs[ index_v0 ]
			 		, uv_v1 = mesh.uvs[ index_v1 ]
			 		, uv_v2 = mesh.uvs[ index_v2 ]
			 		, uv_s_diff = numeric.sub( uv_v1, uv_v0 )
			 		, uv_t_diff = numeric.sub( uv_v2, uv_v0 )
			 		, uv = numeric.add( uv_v0, numeric.mul( inter.s, uv_s_diff ), numeric.mul( inter.t, uv_t_diff ) );</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>a pair representing the param on the polyline and the param on the mesh</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			 	<span class="hljs-keyword">return</span> [ { point: inter.point, p: p, uv: uv, face: included_faces[<span class="hljs-number">0</span>] } ]; 

			}

	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( included_faces.length === <span class="hljs-number">1</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>intersect triangle and polyline</p>
<p>divide polyline in half, rightside includes the pivot</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> crv_points_a = verb.left( crv_points )
			, crv_points_b = verb.rightWithPivot( crv_points )
			, crv_param_points_a = verb.left( crv_param_points )
			, crv_param_points_b = verb.rightWithPivot( crv_param_points );

		<span class="hljs-keyword">return</span> 	 verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb( crv_points_a, crv_param_points_a, mesh, included_faces, tol )
		.concat( verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb( crv_points_b, crv_param_points_b, mesh, included_faces, tol ) );

	
	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( crv_points.length === <span class="hljs-number">2</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>intersect mesh &gt;2 faces and line</p>
<p>divide mesh in &quot;half&quot; by first sorting then dividing array in half</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> sorted_included_faces = verb.eval.mesh.sort_tris_on_longest_axis( mesh_bb, mesh.points, mesh.faces, included_faces )
			, included_faces_a = verb.left( sorted_included_faces )
			, included_faces_b = verb.right( sorted_included_faces );

		<span class="hljs-keyword">return</span> 		 verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb( crv_points, crv_param_points, mesh, included_faces_a, tol )
			.concat( verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb( crv_points, crv_param_points, mesh, included_faces_b, tol ));


	} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>intersect mesh with &gt;2 faces and polyline</p>
<p>divide mesh in &quot;half&quot;</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> sorted_included_faces = verb.eval.mesh.sort_tris_on_longest_axis( mesh_bb, mesh.points, mesh.faces, included_faces )
			, included_faces_a = verb.left( sorted_included_faces )
			, included_faces_b = verb.right( sorted_included_faces );</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>divide polyline in half, rightside includes the pivot</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> crv_points_a = verb.left( crv_points )
			, crv_points_b = verb.rightWithPivot( crv_points )
			, crv_param_points_a = verb.left( crv_param_points )
			, crv_param_points_b = verb.rightWithPivot( crv_param_points );

		<span class="hljs-keyword">return</span> 	 	 verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb( crv_points_a, crv_param_points_a, mesh, included_faces_a, tol )
			.concat( verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb( crv_points_a, crv_param_points_a, mesh, included_faces_b, tol ) )
			.concat( verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb( crv_points_b, crv_param_points_b, mesh, included_faces_a, tol ) )
			.concat( verb.eval.nurbs.intersect_parametric_polyline_mesh_by_aabb( crv_points_b, crv_param_points_b, mesh, included_faces_b, tol ) );

	}

	<span class="hljs-keyword">return</span> [];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <h4 id="intersect_segment_with_tri-p1-p0-points-tri-">intersect_segment_with_tri(  p1, p0, points, tri )</h4>
<p> Intersect segment with triangle (from <a href="http://geomalgorithms.com/a06-_intersect-2.html">http://geomalgorithms.com/a06-_intersect-2.html</a>)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 representing first point of the segment</li>
<li><em>Array</em>, array of length 3 representing second point of the segment</li>
<li><em>Array</em>, array of length 3 arrays representing the points of the triangle</li>
<li><em>Array</em>, array of length 3 containing int indices in the array of points, this allows passing a full mesh</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with an &quot;intersects&quot; property that is true or false and if true, a 
&quot;s&quot; property giving the param on u, and &quot;t&quot; is the property on v, where u is the 
axis from v0 to v1, and v is v0 to v1, a &quot;point&quot; property
where the intersection took place, and &quot;p&quot; property representing the parameter along the segment</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_segment_with_tri = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p0, p1, points, tri )</span> {</span>

	<span class="hljs-keyword">var</span> v0 = points[ tri[<span class="hljs-number">0</span>] ]
		, v1 = points[ tri[<span class="hljs-number">1</span>] ]
		, v2 = points[ tri[<span class="hljs-number">2</span>] ]
		, u = numeric.sub( v1, v0 )
		, v = numeric.sub( v2, v0 )
		, n = numeric.cross( u, v );

	<span class="hljs-keyword">var</span> dir = numeric.sub( p1, p0 )
		, w0 = numeric.sub( p0, v0 )
		, a = -numeric.dot( n, w0 )
		, b = numeric.dot( n, dir )</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p>is ray is parallel to triangle plane?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs( b ) &lt; verb.EPSILON ){ 
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> r = a / b;</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>segment goes away from triangle or is beyond segment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( r &lt; <span class="hljs-number">0</span> || r &gt; <span class="hljs-number">1</span> ){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>get proposed intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> pt = numeric.add( p0, numeric.mul( r, dir ) );</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>is I inside T?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> uv = numeric.dot(u,v)
		, uu = numeric.dot(u,u)
		, vv = numeric.dot(v,v)
		, w = numeric.sub( pt, v0 )
		, wu = numeric.dot( w, u )
		, wv = numeric.dot( w, v )
		, denom = uv * uv - uu * vv
		, s = ( uv * wv - vv * wu ) / denom
		, t = ( uv * wu - uu * wv ) / denom;

	<span class="hljs-keyword">if</span> (s &gt; <span class="hljs-number">1.0</span> + verb.EPSILON || t &gt; <span class="hljs-number">1.0</span> + verb.EPSILON || t &lt; -verb.EPSILON || s &lt; -verb.EPSILON || s + t &gt; <span class="hljs-number">1.0</span> + verb.EPSILON){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">return</span> { point: pt, s: s, t: t, p: r };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <h4 id="intersect_segment_with_plane-p0-p1-v0-n-">intersect_segment_with_plane( p0, p1, v0, n )</h4>
<p> Intersect ray/segment with plane (from <a href="http://geomalgorithms.com/a06-_intersect-2.html">http://geomalgorithms.com/a06-_intersect-2.html</a>)</p>
<p> If intersecting a ray, the param needs to be between 0 and 1 and the caller is responsible
 for making that check</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 representing first point of the segment</li>
<li><em>Array</em>, array of length 3 representing second point of the segment</li>
<li><em>Array</em>, array of length 3 representing an origin point on the plane</li>
<li><em>Array</em>, array of length 3 representing the normal of the plane</li>
</ul>
<p><strong>returns</strong> 
null or an object with a p property representing the param on the segment</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_segment_with_plane = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p0, p1, v0, n )</span> {</span>

	<span class="hljs-keyword">var</span> denom = numeric.dot( n, numeric.sub(p0,p1) );</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>parallel case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( abs( denom ) &lt; EPSILON ) { 
   	<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
 	}

 	<span class="hljs-keyword">var</span> numer = numeric.dot( n, numeric.sub(v0,p0) );

	<span class="hljs-keyword">return</span> { p: numer / denom };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <h4 id="intersect_aabb_trees-points1-tris1-points2-tris2-aabb_tree1-aabb_tree2-">intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2 )</h4>
<p> Intersect two aabb trees - a recursive function</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh2</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh2</li>
<li><em>Object</em>, nested object representing the aabb tree of the first mesh</li>
<li><em>Object</em>, nested object representing the aabb tree of the second mesh</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a list of pairs of triangle indices for mesh1 and mesh2 that are intersecting</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_aabb_trees = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2 )</span> {</span>

  <span class="hljs-keyword">var</span> intersects = aabb_tree1.bounding_box.intersects( aabb_tree2.bounding_box );

  <span class="hljs-keyword">if</span> (!intersects){
  	<span class="hljs-keyword">return</span> [];
  }

  <span class="hljs-keyword">if</span> (aabb_tree1.children.length === <span class="hljs-number">0</span> &amp;&amp; aabb_tree2.children.length === <span class="hljs-number">0</span>){ 

  	<span class="hljs-keyword">return</span> [ [aabb_tree1.triangle, aabb_tree2.triangle ] ]; 

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aabb_tree1.children.length === <span class="hljs-number">0</span> &amp;&amp; aabb_tree2.children.length != <span class="hljs-number">0</span>){

  	<span class="hljs-keyword">return</span>     verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2.children[<span class="hljs-number">0</span>] )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1, aabb_tree2.children[<span class="hljs-number">1</span>] ) );

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aabb_tree1.children.length != <span class="hljs-number">0</span> &amp;&amp; aabb_tree2.children.length === <span class="hljs-number">0</span>){

  	<span class="hljs-keyword">return</span>     verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">0</span>], aabb_tree2 )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">1</span>], aabb_tree2 ) );

  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (aabb_tree1.children.length != <span class="hljs-number">0</span> &amp;&amp; aabb_tree2.children.length != <span class="hljs-number">0</span>){

  	<span class="hljs-keyword">return</span>     verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">0</span>], aabb_tree2.children[<span class="hljs-number">0</span>] )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">0</span>], aabb_tree2.children[<span class="hljs-number">1</span>] ) )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">1</span>], aabb_tree2.children[<span class="hljs-number">0</span>] ) )
  		.concat( verb.eval.geom.intersect_aabb_trees( points1, tris1, points2, tris2, aabb_tree1.children[<span class="hljs-number">1</span>], aabb_tree2.children[<span class="hljs-number">1</span>] ) );

  }

}</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <h4 id="make_mesh_aabb_tree-points-tris-tri_indices-">make_mesh_aabb_tree( points, tris, tri_indices )</h4>
<p>Make tree of axis aligned bounding boxes </p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles</li>
<li><em>Array</em>, array of numbers representing the relevant triangles to use to form aabb</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.make_mesh_aabb_tree = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tris, tri_indices )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>build bb</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> aabb = { 	bounding_box: verb.eval.mesh.make_mesh_aabb( points, tris, tri_indices ), 
								children: [] };</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>if only one ele, terminate recursion and store the triangles</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (tri_indices.length === <span class="hljs-number">1</span>){
		aabb.triangle = tri_indices[<span class="hljs-number">0</span>];
		<span class="hljs-keyword">return</span> aabb;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>sort triangles in sub mesh</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> sorted_tri_indices = verb.eval.mesh.sort_tris_on_longest_axis( aabb.bounding_box, points, tris, tri_indices )
		, tri_indices_a = sorted_tri_indices.slice( <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.floor( sorted_tri_indices.length / <span class="hljs-number">2</span> ) )
		, tri_indices_b = sorted_tri_indices.slice( <span class="hljs-built_in">Math</span>.floor( sorted_tri_indices.length / <span class="hljs-number">2</span> ), sorted_tri_indices.length );</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>recurse </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	aabb.children = [ verb.eval.mesh.make_mesh_aabb_tree(points, tris, tri_indices_a), 
										verb.eval.mesh.make_mesh_aabb_tree(points, tris, tri_indices_b) ];</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>return result</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> aabb;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <h4 id="make_mesh_aabb-points-tris-tri_indices-">make_mesh_aabb( points, tris, tri_indices )</h4>
<p>Form axis-aligned bounding box from triangles of mesh</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles</li>
<li><em>Array</em>, array of numbers representing the relevant triangles</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.make_mesh_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tris, tri_indices )</span> {</span>

	<span class="hljs-keyword">var</span> bb = <span class="hljs-keyword">new</span> verb.geom.BoundingBox();

	tri_indices.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span>{</span>
		bb.add( points[ tris[ x ][<span class="hljs-number">0</span>] ] );
		bb.add( points[ tris[ x ][<span class="hljs-number">1</span>] ] );
		bb.add( points[ tris[ x ][<span class="hljs-number">2</span>] ] );
	});

	<span class="hljs-keyword">return</span> bb;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              <h4 id="sort_tris_on_longest_axis-container_bb-points-tris-tri_indices-">sort_tris_on_longest_axis( container_bb, points, tris, tri_indices )</h4>
<p>Sort triangles on longest axis</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.sort_tris_on_longest_axis = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( container_bb, points, tris, tri_indices )</span> {</span>

	<span class="hljs-keyword">var</span> long_axis = container_bb.get_longest_axis();

	<span class="hljs-keyword">var</span> axis_position_map = [];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = tri_indices.length - <span class="hljs-number">1</span>; i &gt;= <span class="hljs-number">0</span>; i--) {

		<span class="hljs-keyword">var</span> tri_i = tri_indices[i],
			tri_min = verb.eval.mesh.get_min_coordinate_on_axis( points, tris[ tri_i ], long_axis );

		axis_position_map.push( [ tri_min, tri_i ] );

	}

	axis_position_map.sort(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,b)</span> {</span> <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] &gt; b[<span class="hljs-number">0</span>] } );

	<span class="hljs-keyword">var</span> sorted_tri_indices = [];
	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = axis_position_map.length; i &lt; l; i++) {
		sorted_tri_indices.push( axis_position_map[i][<span class="hljs-number">1</span>] );
	}

	<span class="hljs-keyword">return</span> sorted_tri_indices;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <h4 id="get_min_coordinate_on_axis-points-tri-axis-">get_min_coordinate_on_axis( points, tri, axis )</h4>
<p>Get min coordinate on axis</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, length 3 array of point indices for the triangle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, a point represented by an array of length 3</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.get_min_coordinate_on_axis = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tri, axis )</span> {</span>

	<span class="hljs-keyword">var</span> axis_coords = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
		axis_coords.push( points[ tri[i] ][ axis ] );
	}

	<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-built_in">Math</span>, axis_coords);
};</pre></div></div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <h4 id="get_tri_centroid-points-tri-">get_tri_centroid( points, tri )</h4>
<p>Get triangle centroid</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, length 3 array of point indices for the triangle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length 3</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.get_tri_centroid = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tri )</span> {</span>

	<span class="hljs-keyword">var</span> centroid = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++){
			centroid[j] += points[ tri[i] ][j];
		}
	}

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
		centroid[i] /= <span class="hljs-number">3</span>;
	}

	<span class="hljs-keyword">return</span> centroid;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <h4 id="get_tri_norm-points-tri-">get_tri_norm( points, tri )</h4>
<p>Get triangle normal</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points</li>
<li><em>Array</em>, length 3 array of point indices for the triangle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a normal vector represented by an array of length 3</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.get_tri_norm = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points, tri )</span> {</span>

	<span class="hljs-keyword">var</span> v0 = points[ tri[<span class="hljs-number">0</span>] ]
		, v1 = points[ tri[<span class="hljs-number">1</span>] ]
		, v2 = points[ tri[<span class="hljs-number">2</span>] ]
		, u = numeric.sub( v1, v0 )
		, v = numeric.sub( v2, v0 )
		, n = numeric.cross( u, v );

	<span class="hljs-keyword">return</span> numeric.mul( <span class="hljs-number">1</span> / numeric.norm2( n ), n );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <h4 id="intersect_rational_curves_by_aabb_refine-degree1-knots1-homo_control_points1-degree2-knots2-homo_control_points2-sample_tol-tol-">intersect_rational_curves_by_aabb_refine( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol )</h4>
<p>Approximate the intersection of two nurbs surface by axis-aligned bounding box intersection and then refine all solutions.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve1</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 1</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 1</li>
<li><em>Number</em>, integer degree of curve2</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 2</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 2</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and cruve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.intersect_rational_curves_by_aabb_refine = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol )</span> {</span>

	<span class="hljs-keyword">var</span> ints = verb.eval.nurbs.intersect_rational_curves_by_aabb( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol );

	<span class="hljs-keyword">return</span> ints.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(start_params)</span>{</span>
		<span class="hljs-keyword">return</span> verb.eval.nurbs.refine_rational_curve_intersection( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, start_params )
	});

}</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <h4 id="rational_curve_curve_bb_intersect_refine-degree1-knots1-control_points1-degree2-knots2-control_points2-start_params-">rational_curve_curve_bb_intersect_refine( degree1, knots1, control_points1, degree2, knots2, control_points2, start_params )</h4>
<p>Refine an intersection pair for two curves given an initial guess.  This is an unconstrained minimization,
so the caller is responsible for providing a very good initial guess.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve1</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 1</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) for curve 1</li>
<li><em>Number</em>, integer degree of curve2</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 2</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) for curve 2</li>
<li><em>Array</em>, length 2 array with first param guess in first position and second param guess in second position</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a length 3 array containing the [ distance// distance, u1, u2 ]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.refine_rational_curve_intersection = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree1, knots1, control_points1, degree2, knots2, control_points2, start_params )</span> {</span>

	<span class="hljs-keyword">var</span> objective = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span> {</span> 

		<span class="hljs-keyword">var</span> p1 = verb.eval.nurbs.rational_curve_point(degree1, knots1, control_points1, x[<span class="hljs-number">0</span>])
			, p2 = verb.eval.nurbs.rational_curve_point(degree2, knots2, control_points2, x[<span class="hljs-number">1</span>])
			, p1_p2 = numeric.sub(p1, p2);

		<span class="hljs-keyword">return</span> numeric.dot(p1_p2, p1_p2);
	}

	<span class="hljs-keyword">var</span> sol_obj = numeric.uncmin( objective, start_params);
	<span class="hljs-keyword">return</span> sol_obj.solution.concat( sol_obj.f );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <h4 id="intersect_rational_curves_by_aabb-degree1-knots1-homo_control_points1-degree2-knots2-homo_control_points2-sample_tol-tol-">intersect_rational_curves_by_aabb( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol )</h4>
<p>Approximate the intersection of two nurbs surface by axis-aligned bounding box intersection.</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve1</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 1</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 1</li>
<li><em>Number</em>, integer degree of curve2</li>
<li><em>Array</em>, array of nondecreasing knot values for curve 2</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) for curve 2</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of parameter pairs representing the intersection of the two parameteric polylines</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.intersect_rational_curves_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree1, knots1, homo_control_points1, degree2, knots2, homo_control_points2, sample_tol, tol )</span> {</span>

	<span class="hljs-keyword">var</span> up1 = verb.eval.nurbs.rational_curve_adaptive_sample( degree1, knots1, homo_control_points1, sample_tol, <span class="hljs-literal">true</span>)
		, up2 = verb.eval.nurbs.rational_curve_adaptive_sample( degree2, knots2, homo_control_points2, sample_tol, <span class="hljs-literal">true</span>)
		, u1 = up1.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> {</span> <span class="hljs-keyword">return</span> el[<span class="hljs-number">0</span>]; })
		, u2 = up2.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> {</span> <span class="hljs-keyword">return</span> el[<span class="hljs-number">0</span>]; })
		, p1 = up1.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> {</span> <span class="hljs-keyword">return</span> el.slice(<span class="hljs-number">1</span>) })
		, p2 = up2.map( <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(el)</span> {</span> <span class="hljs-keyword">return</span> el.slice(<span class="hljs-number">1</span>) });

	<span class="hljs-keyword">return</span> verb.eval.nurbs.intersect_parametric_polylines_by_aabb( p1, p2, u1, u2, tol );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <h4 id="intersect_parametric_polylines_by_aabb-p1-p2-u1-u2-tol-">intersect_parametric_polylines_by_aabb( p1, p2, u1, u2, tol )</h4>
<p>Intersect two polyline curves, keeping track of parameterization on each</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of point values for curve 1</li>
<li><em>Array</em>, array of parameter values for curve 1, same length as first arg</li>
<li><em>Array</em>, array of point values for curve 2</li>
<li><em>Array</em>, array of parameter values for curve 2, same length as third arg</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, array of parameter pairs representing the intersection of the two parameteric polylines</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.intersect_parametric_polylines_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p1, p2, u1, u2, tol )</span> {</span>

	<span class="hljs-keyword">var</span> bb1 = <span class="hljs-keyword">new</span> verb.geom.BoundingBox(p1)
		, bb2 = <span class="hljs-keyword">new</span> verb.geom.BoundingBox(p2);

	<span class="hljs-keyword">if</span> ( !bb1.intersects(bb2, tol) ) {
		<span class="hljs-keyword">return</span> [];
	}

	<span class="hljs-keyword">if</span> (p1.length === <span class="hljs-number">2</span> &amp;&amp; p2.length === <span class="hljs-number">2</span> ){

			<span class="hljs-keyword">var</span> inter = verb.eval.geom.intersect_segments(p1[<span class="hljs-number">0</span>],p1[<span class="hljs-number">1</span>], p2[<span class="hljs-number">0</span>], p2[<span class="hljs-number">1</span>], tol);

			<span class="hljs-keyword">if</span> ( inter != <span class="hljs-literal">null</span> ){</pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>map the parameters of the segment to the parametric space of the entire polyline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			 	inter[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = inter[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] * ( u1[<span class="hljs-number">1</span>]-u1[<span class="hljs-number">0</span>] ) + u1[<span class="hljs-number">0</span>];
			 	inter[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] = inter[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] * ( u2[<span class="hljs-number">1</span>]-u2[<span class="hljs-number">0</span>] ) + u2[<span class="hljs-number">0</span>];

			 	<span class="hljs-keyword">return</span> [ [ inter[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], inter[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] ] ];

			} 

	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p1.length === <span class="hljs-number">2</span>) {

		<span class="hljs-keyword">var</span> p2_mid = <span class="hljs-built_in">Math</span>.ceil( p2.length / <span class="hljs-number">2</span> ),
				p2_a = p2.slice( <span class="hljs-number">0</span>, p2_mid ),
				p2_b = p2.slice( p2_mid-<span class="hljs-number">1</span> ),
				u2_a = u2.slice( <span class="hljs-number">0</span>, p2_mid ),
				u2_b = u2.slice( p2_mid-<span class="hljs-number">1</span> );

		<span class="hljs-keyword">return</span> 	 verb.eval.nurbs.intersect_parametric_polylines_by_aabb(p1, p2_a, u1, u2_a, tol)
		.concat( verb.eval.nurbs.intersect_parametric_polylines_by_aabb(p1, p2_b, u1, u2_b, tol) );

	} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (p2.length === <span class="hljs-number">2</span>) {

		<span class="hljs-keyword">var</span> p1_mid = <span class="hljs-built_in">Math</span>.ceil( p1.length / <span class="hljs-number">2</span> ),
				p1_a = p1.slice( <span class="hljs-number">0</span>, p1_mid ),
				p1_b = p1.slice( p1_mid-<span class="hljs-number">1</span> ),
				u1_a = u1.slice( <span class="hljs-number">0</span>, p1_mid ),
				u1_b = u1.slice( p1_mid-<span class="hljs-number">1</span> );

		<span class="hljs-keyword">return</span> 		 verb.eval.nurbs.intersect_parametric_polylines_by_aabb(p1_a, p2, u1_a, u2, tol)
			.concat( verb.eval.nurbs.intersect_parametric_polylines_by_aabb(p1_b, p2, u1_b, u2, tol) );

	} <span class="hljs-keyword">else</span> {

		<span class="hljs-keyword">var</span> p1_mid = <span class="hljs-built_in">Math</span>.ceil( p1.length / <span class="hljs-number">2</span> ),
				p1_a = p1.slice( <span class="hljs-number">0</span>, p1_mid ),
				p1_b = p1.slice( p1_mid-<span class="hljs-number">1</span> ),
				u1_a = u1.slice( <span class="hljs-number">0</span>, p1_mid ),
				u1_b = u1.slice( p1_mid-<span class="hljs-number">1</span> ),

				p2_mid = <span class="hljs-built_in">Math</span>.ceil( p2.length / <span class="hljs-number">2</span> ),
				p2_a = p2.slice( <span class="hljs-number">0</span>, p2_mid ),
				p2_b = p2.slice( p2_mid-<span class="hljs-number">1</span> ),
				u2_a = u2.slice( <span class="hljs-number">0</span>, p2_mid ),
				u2_b = u2.slice( p2_mid-<span class="hljs-number">1</span> );

		<span class="hljs-keyword">return</span> 		 verb.eval.nurbs.intersect_parametric_polylines_by_aabb(p1_a, p2_a, u1_a, u2_a, tol)
			.concat( verb.eval.nurbs.intersect_parametric_polylines_by_aabb(p1_a, p2_b, u1_a, u2_b, tol) )
			.concat( verb.eval.nurbs.intersect_parametric_polylines_by_aabb(p1_b, p2_a, u1_b, u2_a, tol) )
			.concat( verb.eval.nurbs.intersect_parametric_polylines_by_aabb(p1_b, p2_b, u1_b, u2_b, tol) );

	}

	<span class="hljs-keyword">return</span> [];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <h4 id="intersect_segments-a0-a1-b0-b1-tol-">intersect_segments( a0, a1, b0, b1, tol )</h4>
<p>Find the closest parameter on two rays, see <a href="http://geomalgorithms.com/a07-_distance.html">http://geomalgorithms.com/a07-_distance.html</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, first point on a</li>
<li><em>Array</em>, second point on a</li>
<li><em>Array</em>, first point on b</li>
<li><em>Array</em>, second point on b</li>
<li><em>Number</em>, tolerance for the intersection</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and cruve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_segments = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( a0, a1, b0, b1, tol )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>get axis and length of segments</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> a1ma0 = numeric.sub(a1, a0),
			aN = <span class="hljs-built_in">Math</span>.sqrt( numeric.dot(a1ma0, a1ma0) ),
			a = numeric.mul( <span class="hljs-number">1</span>/ aN, a1ma0 ),
			b1mb0 = numeric.sub(b1, b0),
			bN = <span class="hljs-built_in">Math</span>.sqrt( numeric.dot(b1mb0, b1mb0) ),
			b = numeric.mul( <span class="hljs-number">1</span> / bN, b1mb0 ),
			int_params = verb.eval.geom.intersect_rays(a0, a, b0, b);

	<span class="hljs-keyword">if</span> ( int_params != <span class="hljs-literal">null</span> ) {

		<span class="hljs-keyword">var</span> u1 = <span class="hljs-built_in">Math</span>.min( <span class="hljs-built_in">Math</span>.max( <span class="hljs-number">0</span>, int_params[<span class="hljs-number">0</span>] / aN ), <span class="hljs-number">1.0</span>),
				u2 = <span class="hljs-built_in">Math</span>.min( <span class="hljs-built_in">Math</span>.max( <span class="hljs-number">0</span>, int_params[<span class="hljs-number">1</span>] / bN ), <span class="hljs-number">1.0</span>),
				int_a = numeric.add( numeric.mul( u1, a1ma0 ), a0 ),
				int_b = numeric.add( numeric.mul( u2, b1mb0 ), b0 ),
				dist = numeric.norm2Squared( numeric.sub(int_a, int_b) );

		<span class="hljs-keyword">if</span> (  dist &lt; tol*tol ) {
			<span class="hljs-keyword">return</span> [ [u1].concat(int_a), [u2].concat(int_b) ] ;
		} 

	}
	
	<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;

 }</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <h4 id="closest_point_on_ray-pt-o-r-">closest_point_on_ray( pt, o, r )</h4>
<p>Find the closest point on a ray</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, point to project</li>
<li><em>Array</em>, origin for ray</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, [param, pt]</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.closest_point_on_ray = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( pt, o, r )</span> {</span>

		<span class="hljs-keyword">var</span> o2pt = numeric.sub(pt,o)
			, do2ptr = numeric.dot(o2pt, r)
			, proj = numeric.add(o, numeric.mul(do2ptr, r));

		<span class="hljs-keyword">return</span> proj;

 }</pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <h4 id="intersect_rays-a0-a-b0-b-">intersect_rays( a0, a, b0, b )</h4>
<p>Find the closest parameter on two rays, see <a href="http://geomalgorithms.com/a07-_distance.html">http://geomalgorithms.com/a07-_distance.html</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, origin for ray 1</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
<li><em>Array</em>, origin for ray 1</li>
<li><em>Array</em>, direction of ray 1, assumed normalized</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a 2d array specifying the intersections on u params of intersections on curve 1 and curve 2</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_rays = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( a0, a, b0, b )</span> {</span>

   <span class="hljs-keyword">var</span> dab = numeric.dot( a, b ),
		   dab0 = numeric.dot( a, b0 ),
		   daa0 = numeric.dot( a, a0 ),
		   dbb0 = numeric.dot( b, b0 ),
		   dba0 = numeric.dot( b, a0 ),
		   daa = numeric.dot( a, a ),
		   dbb = numeric.dot( b, b ),
		   div = daa*dbb - dab*dab;</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <p>parallel case</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>   <span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs( div ) &lt; verb.EPSILON ) { 
	   <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
   }

   <span class="hljs-keyword">var</span> num = dab * (dab0-daa0) - daa * (dbb0-dba0),
   		 w = num / div,
			 t = (dab0 - daa0 + w * dab)/daa;

		<span class="hljs-keyword">return</span> [t, w];

 }</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <h4 id="intersect_meshes_by_aabb-points1-tris1-uvs1-points2-tris2-uvs2-">intersect_meshes_by_aabb( points1, tris1, uvs1, points2, tris2, uvs2 )</h4>
<p>Intersect two meshes via aabb intersection</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.mesh.intersect_meshes_by_aabb = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points1, tris1, uvs1, points2, tris2, uvs2 )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>build aabb for each mesh</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> tri_indices1 = verb.range(tris1.length)
	  , tri_indices2 = verb.range(tris2.length)
	  , aabb1 = verb.eval.mesh.make_mesh_aabb_tree( points1, tris1, tri_indices1 )
	  , aabb2 = verb.eval.mesh.make_mesh_aabb_tree( points2, tris2, tri_indices2 )</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p>intersect and get the pairs of triangle intersctions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		, intersection_pairs = verb.eval.mesh.intersect_aabb_tree( points1, tris1, points2, tris2, aabb1, aabb2 );</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>get the segments of the intersection crv with uvs</p>
<p>sort the intersection segments</p>
<p>TODO</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>}</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <h4 id="intersect_tris-points1-tri1-uvs1-points2-tri2-uvs2-">intersect_tris( points1, tri1, uvs1, points2, tri2, uvs2 )</h4>
<p>Intersect two triangles</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh1</li>
<li><em>Array</em>, array of length 3 arrays of numbers representing the points of mesh2</li>
<li><em>Array</em>, array of length 3 arrays of number representing the triangles of mesh2</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.geom.intersect_tris = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( points1, tri1, uvs1, points2, tri2, uvs2 )</span> {</span>

  <span class="hljs-keyword">var</span> seg1a = [ points1[ tr1[<span class="hljs-number">0</span>] ], points1[ tr1[<span class="hljs-number">1</span>] ] ]
  	, seg1b = [ points1[ tr1[<span class="hljs-number">1</span>] ], points1[ tr1[<span class="hljs-number">2</span>] ] ]
  	, seg1c = [ points1[ tr1[<span class="hljs-number">2</span>] ], points1[ tr1[<span class="hljs-number">0</span>] ] ]
  	, seg2a = [ points2[ tr2[<span class="hljs-number">0</span>] ], points2[ tr2[<span class="hljs-number">1</span>] ] ]
  	, seg2b = [ points2[ tr2[<span class="hljs-number">1</span>] ], points2[ tr2[<span class="hljs-number">2</span>] ] ]
  	, seg2c = [ points2[ tr2[<span class="hljs-number">2</span>] ], points2[ tr2[<span class="hljs-number">0</span>] ] ] 
  	, segs1 = [ seg1a, seg1b, seg1c ]
  	, segs2 = [ seg2a, seg2b, seg2c ]
  	, int_results = []
  	, tri2norm = verb.eval.geom.get_tri_norm(points2, tri2)
  	, pt2 = points2[ tr2[<span class="hljs-number">0</span>] ];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
  	
  	<span class="hljs-keyword">var</span> result = verb.eval.geom.intersect_segment_with_plane( segs1[i][<span class="hljs-number">0</span>], segs2[i][<span class="hljs-number">1</span>], pt2, tri2norm );
    
    <span class="hljs-keyword">if</span> ( result.intersects ){
    	int_results.push( result );
    }

  }</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>if you don&#39;t have 2 intersections you do not have an intersection,
0 would mean a glancing intersection
3 means we don&#39;t have a triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> ( int_results.length !== <span class="hljs-number">2</span> ){
  	<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>what portions of the segment lie within triangle 2</p>
<p>intersect edges of triangle 2 with the segment, obtaining the &quot;inner&quot; triangle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> seg = [int_results[<span class="hljs-number">0</span>].point, int_results[<span class="hljs-number">1</span>].point ]
  	, seg_int_results = [];

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
  	<span class="hljs-keyword">var</span> seg_int_result = verb.eval.geom.intersect_segments( seg[<span class="hljs-number">0</span>], seg[<span class="hljs-number">1</span>], seg, b1, tol );
  	<span class="hljs-keyword">if</span> ( seg_int_result ){
  		seg_int_results.push( seg_int_result );
  	}
  }</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <p>all intersections should be with uv&#39;s </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> ( seg_int_results.length === <span class="hljs-number">0</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              <p>tri1 is intersecting and the intersection segment
is inside tri2</p>
<p>TODO</p>
<p>return the two outer points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( seg_int_results.length === <span class="hljs-number">1</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>tri1 is intersecting and the intersection segment
is partially inside tri2</p>
<p>TODO</p>
<p>return the end point of seg that is INSIDE tri2 and the intersection</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( seg_int_results.length === <span class="hljs-number">2</span> ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p>tri1 is intersecting and the intersection segment&#39;s
end points are outside of tri2</p>
<p>TODO</p>
<p>return the two seg_int_results </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } 

}</pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <h4 id="tesselate_rational_surface_naive-degree_u-knots_u-degree_v-knots_v-homo_control_points-divs_u-divs_v-">tesselate_rational_surface_naive( degree_u, knots_u, degree_v, knots_v, homo_control_points, divs_u, divs_v )</h4>
<p>Tesselate a nurbs surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, first element of array is an array of positions, second element are 3-tuple of triangle windings, third element is the 
uvs</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.tesselate_rational_surface_naive = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, divs_u, divs_v )</span> {</span>

	<span class="hljs-keyword">if</span> ( divs_u &lt; <span class="hljs-number">1</span> ) {
		divs_u = <span class="hljs-number">1</span>;
	}

	<span class="hljs-keyword">if</span> ( divs_v &lt; <span class="hljs-number">1</span> ) {
		divs_v = <span class="hljs-number">1</span>;
	}

	<span class="hljs-keyword">var</span> span_u = <span class="hljs-number">1</span> / divs_u,
		span_v = <span class="hljs-number">1</span> / divs_v;
  
  <span class="hljs-keyword">var</span> points = [];
  <span class="hljs-keyword">var</span> uvs = [];
  <span class="hljs-keyword">var</span> normals = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; divs_u + <span class="hljs-number">1</span>; i++) {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; divs_v + <span class="hljs-number">1</span>; j++) {

			<span class="hljs-keyword">var</span> pt_u = i * span_u, 
				pt_v = j * span_v;

			uvs.push( [pt_u, pt_v] );

			<span class="hljs-keyword">var</span> derivs = verb.eval.nurbs.rational_surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, <span class="hljs-number">1</span>, pt_u, pt_v );
			<span class="hljs-keyword">var</span> pt = derivs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];

			points.push( pt );

			<span class="hljs-keyword">var</span> normal = numeric.cross(  derivs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], derivs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] );
			normals.push( normal );

		}
	}

  	<span class="hljs-keyword">var</span> faces = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; divs_u ; i++) {
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; divs_v ; j++) {

			<span class="hljs-keyword">var</span> a_i = i * (divs_v + <span class="hljs-number">1</span>) + j,
				b_i = (i + <span class="hljs-number">1</span>) * (divs_v + <span class="hljs-number">1</span>) + j,
				c_i = b_i + <span class="hljs-number">1</span>,
				d_i = a_i + <span class="hljs-number">1</span>,
				abc = [a_i, b_i, c_i],
				acd = [a_i, c_i, d_i];

			faces.push(abc);
			faces.push(acd);

		}
	}

	<span class="hljs-keyword">return</span> { points: points, faces : faces, uvs: uvs, normals: normals };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <h4 id="rational_curve_regular_sample-degree-knots-control_points-num_samples-include_u-">rational_curve_regular_sample( degree, knots, control_points, num_samples [, include_u] )</h4>
<p>Sample a NURBS curve assuming parameterization 0 to 1, corresponds to <a href="http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf">http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 1d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) </li>
<li><em>Number</em>, integer number of samples</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array of points, prepended by the point param</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_regular_sample = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, num_samples, include_u )</span> {</span>

	<span class="hljs-keyword">return</span> verb.eval.nurbs.rational_curve_regular_sample_range( degree, knots, control_points, <span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>, num_samples, include_u);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <h4 id="rational_curve_regular_sample_range-degree-knots-control_points-start_u-end_u-num_samples-include_u-">rational_curve_regular_sample_range( degree, knots, control_points, start_u, end_u, num_samples, include_u )</h4>
<p>Sample a NURBS curve assuming parameterization 0 to 1, corresponds to <a href="http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf">http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 1d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi) </li>
<li><em>Number</em>, start parameter for sampling</li>
<li><em>Number</em>, end parameter for sampling</li>
<li><em>Number</em>, integer number of samples</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an dictionary of parameter - point pairs</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_regular_sample_range = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, start_u, end_u, num_samples, include_u )</span> {</span>

	<span class="hljs-keyword">if</span> (num_samples &lt; <span class="hljs-number">1</span>){
		num_samples = <span class="hljs-number">2</span>;
	}

	<span class="hljs-keyword">var</span> p = [],
		span = (end_u - start_u) / (num_samples - <span class="hljs-number">1</span>),
		u = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; num_samples; i++){

		u = start_u + span * i;
		<span class="hljs-keyword">if</span> ( include_u ){
			p.push( [u].concat( verb.eval.nurbs.rational_curve_point(degree, knots, control_points, u) ) );
		} <span class="hljs-keyword">else</span> {
			p.push( verb.eval.nurbs.rational_curve_point(degree, knots, control_points, u) );
		}
	
	}

	<span class="hljs-keyword">return</span> p;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <h4 id="rational_curve_adaptive_sample-degree-knots-control_points-tol-include_u-">rational_curve_adaptive_sample( degree, knots, control_points, tol, include_u )</h4>
<p>Sample a NURBS curve assuming parameterization 0 to 1, corresponds to <a href="http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf">http://ariel.chronotext.org/dd/defigueiredo93adaptive.pdf</a></p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) </li>
<li><em>Number</em>, tolerance for the adaptive scheme</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array of dim + 1 length where the first element is the param where it was sampled and the remaining the pt</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_adaptive_sample = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, tol, include_u )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>if degree is 1, just return the dehomogenized control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (degree === <span class="hljs-number">1</span>){ 
		<span class="hljs-keyword">if</span> ( !include_u ) {
			<span class="hljs-keyword">return</span> control_points.map( verb.eval.nurbs.dehomogenize );
		} <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <p>the first element of each array is the parameter</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> control_points.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x, i)</span>{</span>
				<span class="hljs-keyword">return</span> [ knots[i+<span class="hljs-number">1</span>] ].concat( verb.eval.nurbs.dehomogenize( x ) );
			});
		}
	}

	<span class="hljs-keyword">return</span> verb.eval.nurbs.rational_curve_adaptive_sample_range( degree, knots, control_points, <span class="hljs-number">0</span>, <span class="hljs-number">1.0</span>, tol, include_u );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <h4 id="rational_curve_adaptive_sample_range-degree-knots-control_points-start_u-end_u-tol-include_u-">rational_curve_adaptive_sample_range( degree, knots, control_points, start_u, end_u, tol, include_u )</h4>
<p>Sample a NURBS curve at 3 points, facilitating adaptive sampling</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values </li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi) </li>
<li><em>Number</em>, start parameter for sampling</li>
<li><em>Number</em>, end parameter for sampling</li>
<li><em>Boolean</em>, whether to prefix the point with the parameter</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array of dim + 1 length where the first element is the param where it was sampled and the remaining the pt</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_adaptive_sample_range = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, start_u, end_u, tol, include_u )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <p>sample curve at three pts</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> p1 = verb.eval.nurbs.rational_curve_point(degree, knots, control_points, start_u),
		p3 = verb.eval.nurbs.rational_curve_point(degree, knots, control_points, end_u),
		t = <span class="hljs-number">0.5</span> + <span class="hljs-number">0.2</span> * <span class="hljs-built_in">Math</span>.random(),
		mid_u = start_u + (end_u - start_u) * t,
		p2 = verb.eval.nurbs.rational_curve_point(degree, knots, control_points, mid_u);</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <p>if the two end control points are coincident, the three point test will always return 0, let&#39;s split the curve</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> diff = numeric.sub( p1, p3);
		<span class="hljs-keyword">var</span> diff2 = numeric.sub( p1, p2);</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>the first condition checks if the curve makes up a loop, if so, we will need to continue evaluation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">if</span> ( ( numeric.dot( diff, diff ) &lt; tol &amp;&amp; numeric.dot( diff2, diff2 ) &gt; tol ) || !verb.eval.nurbs.three_points_are_flat( p1, p2, p3, tol ) ) {</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <p>get the exact middle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> exact_mid_u = start_u + (end_u - start_u) * <span class="hljs-number">0.5</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              <p>recurse on the two halves</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> left_pts = verb.eval.nurbs.rational_curve_adaptive_sample_range( degree, knots, control_points, start_u, exact_mid_u, tol, include_u )
				, right_pts = verb.eval.nurbs.rational_curve_adaptive_sample_range( degree, knots, control_points, exact_mid_u, end_u, tol, include_u );</pre></div></div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <p>concatenate the two        </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span> left_pts.slice(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>).concat(right_pts);

		} <span class="hljs-keyword">else</span> {

			<span class="hljs-keyword">if</span> (include_u){
				<span class="hljs-keyword">return</span> [ 	[ start_u ].concat(p1) , [end_u].concat(p3) ];
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">return</span> [ 	p1, p3 ];
			}

		}
}</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <h4 id="three_points_are_flat-p1-p2-p3-tol-">three_points_are_flat( p1, p2, p3, tol )</h4>
<p>Determine if three points form a straight line within a given tolerance for their 2 * squared area</p>
<pre><code>     * p2
    / \
   /   \
  /     \ 
 /       \
* p1 ---- * p3
</code></pre><p>The area metric is 2 * the squared norm of the cross product of two edges, requiring no square roots and no divisions</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, p1</li>
<li><em>Array</em>, p2</li>
<li><em>Array</em>, p3</li>
<li><em>Number</em>, The tolerance for whether the three points form a line</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, Whether the triangle passes the test</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.three_points_are_flat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p1, p2, p3, tol )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <p>find the area of the triangle without using a square root</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> p2mp1 = numeric.sub( p2, p1 )
		, p3mp1 = numeric.sub( p3, p1 )
		, norm = crossprod( p2mp1, p3mp1 )
		, area = numeric.dot( norm, norm );

	<span class="hljs-keyword">return</span> area &lt; tol;

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getEastNeighbor</span><span class="hljs-params">(index, i, j, min_divs_u, min_divs_v, divs)</span>{</span>
	
	<span class="hljs-keyword">if</span> (j === min_divs_v - <span class="hljs-number">1</span>){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">return</span> divs[ index + <span class="hljs-number">1</span> ];

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getNorthNeighbor</span><span class="hljs-params">(index, i, j, min_divs_u, min_divs_v, divs)</span>{</span>

	<span class="hljs-keyword">if</span> (i === <span class="hljs-number">0</span>){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">return</span> divs[ index - min_divs_v ];

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getSouthNeighbor</span><span class="hljs-params">(index, i, j, min_divs_u, min_divs_v, divs)</span>{</span>

	<span class="hljs-keyword">if</span> (i === min_divs_u - <span class="hljs-number">1</span>){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">return</span> divs[ index + min_divs_v ];

}

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getWestNeighbor</span><span class="hljs-params">(index, i, j, min_divs_u, min_divs_v, divs)</span>{</span>

	<span class="hljs-keyword">if</span> (j === <span class="hljs-number">0</span>){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">return</span> divs[ index - <span class="hljs-number">1</span> ];

}

verb.eval.nurbs.divide_rational_surface_adaptive = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, options )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>degree_u, knots_u, degree_v, knots_v, homo_control_points, </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> srf = {
		degree_u: degree_u,
		knots_u: knots_u,
		degree_v: degree_v,
		knots_v: knots_v,
		homo_control_points: homo_control_points
	};

	<span class="hljs-keyword">var</span> min_divs_u = options.minDivsU;
	<span class="hljs-keyword">var</span> min_divs_v = options.minDivsV;</pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <p>get necessary intervals</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> max_u = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, knots_u);
	<span class="hljs-keyword">var</span> min_u = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, knots_u);
	<span class="hljs-keyword">var</span> max_v = <span class="hljs-built_in">Math</span>.max.apply(<span class="hljs-literal">null</span>, knots_v);
	<span class="hljs-keyword">var</span> min_v = <span class="hljs-built_in">Math</span>.min.apply(<span class="hljs-literal">null</span>, knots_v);

	<span class="hljs-keyword">var</span> u_interval = (max_u - min_u) / min_divs_u
		, v_interval = (max_v - min_v) / min_divs_v;

	<span class="hljs-keyword">var</span> divs = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <p>make all of the nodes</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; min_divs_u; i++){
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; min_divs_v; j++){

			<span class="hljs-keyword">var</span> u0 = min_u + u_interval * i
				, u1 = min_u + u_interval * (i + <span class="hljs-number">1</span>)
				, v0 = min_v + v_interval * j
				, v1 = min_v + v_interval * (j + <span class="hljs-number">1</span>);

		  divs.push( <span class="hljs-keyword">new</span> verb.eval.nurbs.AdaptiveRefinementNode( srf, u0, u1, v0, v1, <span class="hljs-literal">null</span>, <span class="hljs-literal">null</span> ) );

		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>assign all of the neighbors and divide</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; min_divs_u; i++){
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; min_divs_v; j++){

			<span class="hljs-keyword">var</span> index = i * min_divs_v + j
				, n = getNorthNeighbor( index, i, j, min_divs_u, min_divs_v, divs )
				, e = getEastNeighbor( index, i, j, min_divs_u, min_divs_v, divs  )
				, s = getSouthNeighbor( index, i, j, min_divs_u, min_divs_v, divs )
				, w = getWestNeighbor( index, i, j, min_divs_u, min_divs_v, divs  );

		  divs[index].neighbors = [ n, e, s, w ];

		  divs.divide( options );

		}
	}

	<span class="hljs-keyword">return</span> divs;

}

verb.eval.nurbs.is_rational_surface_domain_flat = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(srf, u0, u1, v0, v1, options )</span>{</span>

	<span class="hljs-keyword">var</span> max_crv_diff = options.maxCurvatureDifference || <span class="hljs-number">0.01</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <p>get curvature at all corners of the surface</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> type = <span class="hljs-string">"gaussian"</span>;

	<span class="hljs-keyword">var</span> a = verb.eval.nurbs.rational_surface_curvature( srf.degree_u, 
																											srf.knots_u, 
																											srf.degree_v, 
																											srf.knots_v, 
																											srf.homo_control_points, 
																											u0, v0 );

	<span class="hljs-keyword">var</span> b = verb.eval.nurbs.rational_surface_curvature( srf.degree_u, 
																											srf.knots_u, 
																											srf.degree_v, 
																											srf.knots_v, 
																											srf.homo_control_points, 
																											u1, v0 );

	<span class="hljs-keyword">var</span> c = verb.eval.nurbs.rational_surface_curvature( srf.degree_u, 
																											srf.knots_u, 
																											srf.degree_v, 
																											srf.knots_v, 
																											srf.homo_control_points, 
																											u1, v1 );

	<span class="hljs-keyword">var</span> d = verb.eval.nurbs.rational_surface_curvature( srf.degree_u, 
																											srf.knots_u, 
																											srf.degree_v, 
																											srf.knots_v, 
																											srf.homo_control_points, 
																											u0, v1 );

	<span class="hljs-keyword">var</span> e = verb.eval.nurbs.rational_surface_curvature( srf.degree_u, 
																											srf.knots_u, 
																											srf.degree_v, 
																											srf.knots_v, 
																											srf.homo_control_points, 
																											(u0 + u1) / <span class="hljs-number">2</span>, (v0 + v1) / <span class="hljs-number">2</span> );

	<span class="hljs-keyword">var</span> curvatures = [ a.mean, b.mean, c.mean, d.mean, e.mean ];
	<span class="hljs-keyword">var</span> points = [ a.point, b.point, c.point, d.point, e.point ];</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <p>if any of the curvatures are greater than threshold - return false</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++){
		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = i+<span class="hljs-number">1</span>; j &lt; <span class="hljs-number">5</span>; j++){
			<span class="hljs-keyword">if</span> ( <span class="hljs-built_in">Math</span>.abs( curvatures[i] - curvatures[j] ) &gt; curvatureDifference ){
				<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
			}
		}
	}

	<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <p>var eval_srf = verb.eval.nurbs.rational_surface_point
    , u_half_step = (u[1] - u[0] / 2) <em> ( Math.random() </em> 0.1 + 1 )
    , v_half_step = (v[1] - v[0] / 2) <em> ( Math.random() </em> 0.1 + 1 )
    , p1 = eval_srf( srf.degree_u, srf.knots_u, srf.degree_v, srf.knots_v, srf.homo_control_points, u[0], v[0] )
    , p2 = eval_srf( srf.degree_u, srf.knots_u, srf.degree_v, srf.knots_v, srf.homo_control_points, u[0] + u_half_step, v[0] + v_half_step )
    , p3 = eval_srf( srf.degree_u, srf.knots_u, srf.degree_v, srf.knots_v, srf.homo_control_points, u[1], v[1] );</p>
<p>return verb.eval.nurbs.three_points_are_flat( p1, p2 , p3, tol );</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>}

verb.eval.nurbs.triangulate_adaptive_refinement_node_tree = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( arrTree )</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <p>triangulate all of the nodes of the tree</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> mesh = { uvs : [], points : [], normals : [], faces : [] };
	mesh.faces = arrTree.map(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span>{</span>  x.triangulate( mesh ); }).flatten();
	<span class="hljs-keyword">return</span> mesh;

};

verb.eval.nurbs.tesselate_rational_surface_adaptive = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, options )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <p>division step</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> arrArray = verb.eval.nurbs.divide_rational_surface_adaptive( degree_u, knots_u, degree_v, knots_v, homo_control_points, options );</pre></div></div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              <p>triangulation step</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> res = verb.eval.nurbs.triangulate_adaptive_refinement_node_tree( arrTree );

	<span class="hljs-keyword">return</span> verb.eval.nurbs.unique_mesh( res );

}

verb.eval.nurbs.unique_mesh = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mesh )</span> {</span>

	<span class="hljs-keyword">return</span> mesh;

}


<span class="hljs-built_in">Array</span>.prototype.where = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( predicate )</span>{</span>

	<span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.length === <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

	<span class="hljs-keyword">var</span> res = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++){
		<span class="hljs-keyword">if</span> ( predicate( <span class="hljs-keyword">this</span>[i] ) ) res.push( <span class="hljs-keyword">this</span>[i] );
	}

	<span class="hljs-keyword">return</span> res;

}

verb.eval.nurbs.AdaptiveRefinementNode = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( srf, u0, u1, v0, v1, parentNode, neighbors )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <p>Structure of the child nodes
in the adaptive refinement tree</p>
<p> +--&gt; u
 |
 v
 v</p>
<pre><code>                   neighbors[0]

           (u0,v0)---(u05,v0)---(u1,v0)
             |           |          |
             |     0     |     1    |
             |           |          |
</code></pre><p>neighbors[3]   (u0,v05)--(u05,v05)--(u1,v05)   neighbors[1] 
                 |           |          | 
                 |     3     |     2    |
                 |           |          |
               (u0,v1)---(u05,v1)---(u1,v1)</p>
<pre><code>                   neighbors[2]
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.srf = srf;
	<span class="hljs-keyword">this</span>.u0 = u0;
	<span class="hljs-keyword">this</span>.u1 = u1;
	<span class="hljs-keyword">this</span>.v0 = v0;
	<span class="hljs-keyword">this</span>.v1 = v1;
	<span class="hljs-keyword">this</span>.parentNode = parentNode;
	<span class="hljs-keyword">this</span>.neighbors = neighbors;
	<span class="hljs-keyword">this</span>.leafEdgeUvs = [[ u0, v0 ], [ u1, v0 ], [ u1, v1 ], [ u0, v1 ]];
	<span class="hljs-keyword">this</span>.cachedEdgeUvs = [];

}

verb.eval.nurbs.AdaptiveRefinementNode.prototype.isLeaf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span>{</span>
	<span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.children === <span class="hljs-literal">undefined</span>);
};


verb.eval.nurbs.AdaptiveRefinementNode.prototype.evalSurface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( uv )</span>{</span>

	<span class="hljs-keyword">var</span> derivs = verb.eval.nurbs.rational_surface_derivs( <span class="hljs-keyword">this</span>.srf.degree_u, 
																												<span class="hljs-keyword">this</span>.srf.knots_u, 
																												<span class="hljs-keyword">this</span>.srf.degree_v, 
																												<span class="hljs-keyword">this</span>.srf.knots_v, 
																												<span class="hljs-keyword">this</span>.srf.homo_control_points, 
																												<span class="hljs-number">1</span>, 
																												pt_u, 
																												pt_v );
	<span class="hljs-keyword">var</span> pt = derivs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];

	points.push( pt );

	<span class="hljs-keyword">var</span> normal = numeric.cross(  derivs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], derivs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>] );

	<span class="hljs-keyword">return</span> { point: pt, normal: normal };

};


verb.eval.nurbs.AdaptiveRefinementNode.prototype.getEdgeUvs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( edgeIndex )</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <p>if its a leaf, there are no children to obtain uvs from</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.isLeaf() ) <span class="hljs-keyword">return</span> [ <span class="hljs-keyword">this</span>.leafEdgeUvs[ edgeIndex ] ]</pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>get the uvs owned by the children along this edge</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.cachedEdgeUvs[edgeIndex] = <span class="hljs-keyword">this</span>.cachedEdgeUvs[edgeIndex] || <span class="hljs-keyword">this</span>.children[ edgeIndex ].getEdgeUvs( edgeIndex )
																						 												.concat( <span class="hljs-keyword">this</span>.children[ (edgeIndex + <span class="hljs-number">1</span>) % <span class="hljs-number">4</span> ].getEdgeUvs( edgeIndex ));
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.cachedEdgeUvs[edgeIndex];
};

verb.eval.nurbs.AdaptiveRefinementNode.prototype.getAllEdgeUvs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( edgeIndex )</span>{</span>

	<span class="hljs-keyword">var</span> baseArr = [ <span class="hljs-keyword">this</span>.leafEdgeUvs[edgeIndex] ];

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.neighbors[edgeIndex] === <span class="hljs-literal">null</span> ) <span class="hljs-keyword">return</span> baseArr;</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <p>get opposite edges uvs</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> uvs = <span class="hljs-keyword">this</span>.neighbors[edgeIndex].getEdgeUvs( ( edgeIndex + <span class="hljs-number">2</span> ) % <span class="hljs-number">4</span> );

	<span class="hljs-keyword">var</span> funcIndex = edgeIndex % <span class="hljs-number">2</span>;

	<span class="hljs-keyword">var</span> that = <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>
              <p>range clipping functions</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> rangeFuncMap = [
		<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span>{</span> <span class="hljs-keyword">return</span> x[<span class="hljs-number">0</span>] &gt; that.u0 + verb.EPSILON &amp;&amp; x[<span class="hljs-number">0</span>] &lt; that.u1 - verb.EPSILON; },
		<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span>{</span> <span class="hljs-keyword">return</span> x[<span class="hljs-number">1</span>] &gt; that.v0 + verb.EPSILON &amp;&amp; x[<span class="hljs-number">1</span>] &lt; that.v1 - verb.EPSILON; }
	];</pre></div></div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <p>clip the range of uvs to match this one</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> baseArr.concat( uvs.where( rangeFuncMap[ funcIndex ] ).reverse() ) ;

};

verb.eval.nurbs.AdaptiveRefinementNode.prototype.triangulateLeaf = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mesh )</span>{</span>

		<span class="hljs-keyword">var</span> baseIndex = mesh.points.length - <span class="hljs-number">1</span>;

		<span class="hljs-keyword">var</span> uvs = [];</pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>
              <p>enumerate all uvs in counter clockwise direction</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++){
			uvs.concat( <span class="hljs-keyword">this</span>.getAllEdgeUvs(i) ); 
		}

		uvs.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span>{</span>
			mesh.uvs.push(x);
			<span class="hljs-keyword">var</span> point = <span class="hljs-keyword">this</span>.evalSurface( x );

			mesh.points.push( point.point );
			mesh.normals.push( point.normal );

		});

		<span class="hljs-keyword">if</span> (uvs.length === <span class="hljs-number">4</span>){</pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>
              <p>if the number of points is 4, we&#39;re just doing a
rectangle - just build the basic triangulated square</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			mesh.faces.push( [ baseIndex + <span class="hljs-number">1</span>, baseIndex + <span class="hljs-number">4</span>, baseIndex + <span class="hljs-number">2</span> ] );
			mesh.faces.push( [ baseIndex + <span class="hljs-number">4</span>, baseIndex + <span class="hljs-number">3</span>, baseIndex + <span class="hljs-number">2</span> ] );</pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <p>all done ;)</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">return</span>;

		}

		<span class="hljs-keyword">this</span>.u05 = <span class="hljs-keyword">this</span>.u05 || (<span class="hljs-keyword">this</span>.u0 + <span class="hljs-keyword">this</span>.u1) / <span class="hljs-number">2</span>;
		<span class="hljs-keyword">this</span>.v05 = <span class="hljs-keyword">this</span>.v05 || (<span class="hljs-keyword">this</span>.v0 + <span class="hljs-keyword">this</span>.v1) / <span class="hljs-number">2</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>
              <p>make point at center of face</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		mesh.uvs.push( [  <span class="hljs-keyword">this</span>.u05, <span class="hljs-keyword">this</span>.v05 ] );
		<span class="hljs-keyword">var</span> center = <span class="hljs-keyword">this</span>.evalSurface( [ <span class="hljs-keyword">this</span>.u05, <span class="hljs-keyword">this</span>.v05 ] );
		mesh.points.push( center.point );
		mesh.normals.push( center.normal );</pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>
              <p>get index </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> centerIndex = mesh.points.length - <span class="hljs-number">1</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <p>build triangle fan from center</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; uvs.length; i++){

			mesh.faces.push( [	centerIndex, 
													(baseIndex + i + <span class="hljs-number">2</span>) % uvs.length, 
													(baseIndex + i + <span class="hljs-number">1</span>) % uvs.length   ]);

		}

};

verb.eval.nurbs.AdaptiveRefinementNode.prototype.triangulate = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( mesh )</span>{</span>

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.isLeaf() ) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.triangulateLeaf( mesh );</pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <p>recurse on the children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.children.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span>{</span>
		<span class="hljs-keyword">if</span> (x === <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;
		x.triangulate( mesh );
	});

};

verb.eval.nurbs.AdaptiveRefinementNode.prototype.shouldDivide = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options, currentDepth )</span>{</span>

	<span class="hljs-keyword">if</span> ( ( options.minDepth &amp;&amp; currentDepth &lt; options.minDepth ) ){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}

	<span class="hljs-keyword">if</span> ( <span class="hljs-keyword">this</span>.srf &amp;&amp; !verb.eval.nurbs.is_rational_surface_domain_flat( <span class="hljs-keyword">this</span>.srf, <span class="hljs-keyword">this</span>.u0, <span class="hljs-keyword">this</span>.u1, <span class="hljs-keyword">this</span>.v0, <span class="hljs-keyword">this</span>.v1, options ) ){
		<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
	}

	<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;

}

verb.eval.nurbs.AdaptiveRefinementNode.prototype.divide = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( options, currentDepth )</span>{</span></pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>
              <p>initialize currentDepth if it&#39;s not present</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (currentDepth === <span class="hljs-literal">undefined</span>) currentDepth = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">if</span> ( !<span class="hljs-keyword">this</span>.shouldDivide( options, currentDepth )  ) <span class="hljs-keyword">return</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>
              <p>increment the depth</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	currentDepth++;</pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <p>divide the domain</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.u05 = (<span class="hljs-keyword">this</span>.u0 + <span class="hljs-keyword">this</span>.u1) / <span class="hljs-number">2</span>;
	<span class="hljs-keyword">this</span>.v05 = (<span class="hljs-keyword">this</span>.v0 + <span class="hljs-keyword">this</span>.v1) / <span class="hljs-number">2</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <p>create the children</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.children = [ 	<span class="hljs-keyword">new</span> verb.eval.nurbs.AdaptiveRefinementNode( <span class="hljs-keyword">this</span>.srf, <span class="hljs-keyword">this</span>.u0, <span class="hljs-keyword">this</span>.u05, 	<span class="hljs-keyword">this</span>.v0, 	<span class="hljs-keyword">this</span>.v05, <span class="hljs-keyword">this</span> ),
											<span class="hljs-keyword">new</span> verb.eval.nurbs.AdaptiveRefinementNode( <span class="hljs-keyword">this</span>.srf, <span class="hljs-keyword">this</span>.u05, <span class="hljs-keyword">this</span>.u1, 	<span class="hljs-keyword">this</span>.v0, 	<span class="hljs-keyword">this</span>.v05, <span class="hljs-keyword">this</span> ),
											<span class="hljs-keyword">new</span> verb.eval.nurbs.AdaptiveRefinementNode( <span class="hljs-keyword">this</span>.srf, <span class="hljs-keyword">this</span>.u05, <span class="hljs-keyword">this</span>.u1, 	<span class="hljs-keyword">this</span>.v05, <span class="hljs-keyword">this</span>.v1, 	<span class="hljs-keyword">this</span> ),
											<span class="hljs-keyword">new</span> verb.eval.nurbs.AdaptiveRefinementNode( <span class="hljs-keyword">this</span>.srf, <span class="hljs-keyword">this</span>.u0, 	<span class="hljs-keyword">this</span>.u05, <span class="hljs-keyword">this</span>.v05, <span class="hljs-keyword">this</span>.v1, 	<span class="hljs-keyword">this</span> ) ];</pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>
              <p>correctly assign neighbors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>].neighbors = [ <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.children[<span class="hljs-number">3</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">3</span>] ];
	<span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>].neighbors = [ <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.children[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>] ];
	<span class="hljs-keyword">this</span>.children[<span class="hljs-number">2</span>].neighbors = [ <span class="hljs-keyword">this</span>.children[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">1</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.children[<span class="hljs-number">3</span>] ];
	<span class="hljs-keyword">this</span>.children[<span class="hljs-number">3</span>].neighbors = [ <span class="hljs-keyword">this</span>.children[<span class="hljs-number">0</span>], <span class="hljs-keyword">this</span>.children[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">2</span>], <span class="hljs-keyword">this</span>.neighbors[<span class="hljs-number">3</span>] ];</pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>
              <p>divide all children recursively</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">this</span>.children.forEach(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(x)</span>{</span> x.divide( options,currentDepth ); })

};</pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <h3 id="verb-eval">verb.eval</h3>
<p>This defines verb&#39;s core geometry library which is called by the current Engine.</p>
<h4 id="get_sweep1_surface-profile_knots-profile_degree-profile_control_points-profile_weights-rail_knots-rail_degree-rail_control_points-rail_weights-">get_sweep1_surface( profile_knots, profile_degree, profile_control_points, profile_weights, rail_knots, rail_degree, rail_control_points, rail_weights )</h4>
<p>Generate the control points, weights, and knots of an elliptical arc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center</li>
<li><em>Array</em>, the xaxis</li>
<li><em>Array</em>, orthogonal yaxis</li>
<li><em>Number</em>, xradius of the ellipse arc</li>
<li><em>Number</em>, yradius of the ellipse arc</li>
<li><em>Number</em>, start angle of the ellipse arc, between 0 and 2pi, where 0 points at the xaxis</li>
<li><em>Number</em>, end angle of the arc, between 0 and 2pi, greater than the start angle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_sweep1_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( profile_knots, profile_degree, profile_control_points, profile_weights, rail_knots, rail_degree, rail_control_points, rail_weights )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>
              <p>for each point on rail, move all of the points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> homo_rail = verb.eval.nurbs.homogenize_1d( rail_control_points, rail_weights )
		, rail_start = verb.eval.nurbs.rational_curve_point( rail_degree, rail_knots, homo_rail, <span class="hljs-number">0</span> )
		, span = <span class="hljs-number">1.0</span> / rail_control_points.length
		, control_points = []
		, weights = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rail_control_points.length; i++ ){</pre></div></div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>
              <p>evaluate the point on the curve, subtracting it from the first point</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> rail_point = verb.eval.nurbs.rational_curve_point( rail_degree, rail_knots, homo_rail, i * span )
			, rail_offset = numeric.sub( rail_point, rail_start )
			, row_control_points = []
			, row_weights = [];

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; profile_control_points.length; j++ ){

			row_control_points.push( numeric.add(rail_offset, profile_control_points[j] ) );
			row_weights.push( profile_weights[j] * rail_weights[i] );

		}

		control_points.push( row_control_points);
		weights.push( row_weights );
	}

	<span class="hljs-keyword">return</span> {<span class="hljs-string">"knots_u"</span>: rail_knots, 
			<span class="hljs-string">"knots_v"</span>: profile_knots,
			<span class="hljs-string">"control_points"</span>: control_points, 
			<span class="hljs-string">"degree_u"</span>: rail_degree, 
			<span class="hljs-string">"degree_v"</span>: profile_degree, 
			<span class="hljs-string">"weights"</span>: weights };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <h4 id="get_ellipse_arc-center-xaxis-yaxis-xradius-yradius-start_angle-end_angle-">get_ellipse_arc( center, xaxis, yaxis, xradius, yradius, start_angle, end_angle )</h4>
<p>Generate the control points, weights, and knots of an elliptical arc</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center</li>
<li><em>Array</em>, the xaxis</li>
<li><em>Array</em>, orthogonal yaxis</li>
<li><em>Number</em>, xradius of the ellipse arc</li>
<li><em>Number</em>, yradius of the ellipse arc</li>
<li><em>Number</em>, start angle of the ellipse arc, between 0 and 2pi, where 0 points at the xaxis</li>
<li><em>Number</em>, end angle of the arc, between 0 and 2pi, greater than the start angle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_ellipse_arc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, xaxis, yaxis, xradius, yradius, start_angle, end_angle )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>
              <p>if the end angle is less than the start angle, do a circle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (end_angle &lt; start_angle) end_angle = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI + start_angle;

	<span class="hljs-keyword">var</span> theta = end_angle - start_angle
		, narcs = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-223">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-223">&#182;</a>
              </div>
              <p>how many arcs?</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>) {
		narcs = <span class="hljs-number">1</span>;
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-built_in">Math</span>.PI){
			narcs = <span class="hljs-number">2</span>;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-number">3</span> * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>){
			narcs = <span class="hljs-number">3</span>;
		} <span class="hljs-keyword">else</span> {
			narcs = <span class="hljs-number">4</span>;
		}
	}

	<span class="hljs-keyword">var</span> dtheta = theta / narcs
		, n = <span class="hljs-number">2</span> * narcs
		, w1 = <span class="hljs-built_in">Math</span>.cos( dtheta / <span class="hljs-number">2</span>) 
		, P0 = numeric.add( center, numeric.mul( xradius, <span class="hljs-built_in">Math</span>.cos(start_angle), xaxis), numeric.mul( yradius, <span class="hljs-built_in">Math</span>.sin(start_angle), yaxis ) )
		, T0 = numeric.sub( numeric.mul( <span class="hljs-built_in">Math</span>.cos(start_angle), yaxis ), numeric.mul( <span class="hljs-built_in">Math</span>.sin(start_angle), xaxis) )
		, Pw = verb.eval.nurbs.zeros_1d( narcs * <span class="hljs-number">2</span> )
		, U = verb.eval.nurbs.zeros_1d( <span class="hljs-number">2</span> *narcs + <span class="hljs-number">3</span> )
		, index = <span class="hljs-number">0</span>
		, angle = start_angle
		, W = verb.eval.nurbs.zeros_1d( narcs * <span class="hljs-number">2</span> );

	Pw[<span class="hljs-number">0</span>] = P0;
	W[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= narcs; i++){

		angle += dtheta;
		<span class="hljs-keyword">var</span> P2 = numeric.add( center, numeric.mul( xradius, <span class="hljs-built_in">Math</span>.cos(angle), xaxis), numeric.mul( yradius, <span class="hljs-built_in">Math</span>.sin(angle), yaxis ) )

		W[index+<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>;
		Pw[index+<span class="hljs-number">2</span>] = P2;

		<span class="hljs-keyword">var</span> T2 = numeric.sub( numeric.mul( <span class="hljs-built_in">Math</span>.cos(angle), yaxis ), numeric.mul( <span class="hljs-built_in">Math</span>.sin(angle), xaxis) )

		<span class="hljs-keyword">var</span> params = verb.eval.geom.intersect_rays(P0, numeric.mul( <span class="hljs-number">1</span> / numeric.norm2(T0), T0), P2, numeric.mul( <span class="hljs-number">1</span> / numeric.norm2(T2), T2));
		<span class="hljs-keyword">var</span> P1 = numeric.add( P0, numeric.mul(T0, params[<span class="hljs-number">0</span>]));

		W[index+<span class="hljs-number">1</span>] = w1;
		Pw[index+<span class="hljs-number">1</span>] = P1;

		index += <span class="hljs-number">2</span>;

		<span class="hljs-keyword">if</span> (i &lt; narcs){
			P0 = P2;
			T0 = T2;
		}
	}

	<span class="hljs-keyword">var</span> j = <span class="hljs-number">2</span> *  narcs + <span class="hljs-number">1</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; i++){
		U[i] = <span class="hljs-number">0.0</span>;
		U[i+j] = <span class="hljs-number">1.0</span>;
	}

	<span class="hljs-keyword">switch</span> (narcs){
		<span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: U[<span class="hljs-number">3</span>] = U[<span class="hljs-number">4</span>] = <span class="hljs-number">0.5</span>; <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: U[<span class="hljs-number">3</span>] = U[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>/<span class="hljs-number">3</span>;
						U[<span class="hljs-number">5</span>] = U[<span class="hljs-number">6</span>] = <span class="hljs-number">2</span>/<span class="hljs-number">3</span>; <span class="hljs-keyword">break</span>;
		<span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: U[<span class="hljs-number">3</span>] = U[<span class="hljs-number">4</span>] = <span class="hljs-number">0.25</span>;
						U[<span class="hljs-number">5</span>] = U[<span class="hljs-number">6</span>] = <span class="hljs-number">0.5</span>;
						U[<span class="hljs-number">7</span>] = U[<span class="hljs-number">8</span>] = <span class="hljs-number">0.75</span>; <span class="hljs-keyword">break</span>;
	}

	<span class="hljs-keyword">return</span> {knots: U, control_points: Pw, degree: <span class="hljs-number">2</span>, weights: W };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-224">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-224">&#182;</a>
              </div>
              <h4 id="get_sphere_surface-center-axis-xaxis-radius-">get_sphere_surface( center, axis, xaxis, radius )</h4>
<p>Generate the control points, weights, and knots of a sphere</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center of the sphere</li>
<li><em>Array</em>, normalized axis of sphere</li>
<li><em>Array</em>, vector perpendicular to axis of sphere, starting the rotation of the sphere</li>
<li><em>Number</em>, radius of the sphere</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots_u, knots_v, degree_u, degree_v</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_sphere_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, axis, xaxis, radius )</span>{</span>

	<span class="hljs-keyword">var</span> arc = verb.eval.nurbs.get_arc(center, numeric.mul(axis, -<span class="hljs-number">1</span>), xaxis, radius, <span class="hljs-number">0</span>, <span class="hljs-built_in">Math</span>.PI );

	<span class="hljs-keyword">return</span> verb.eval.nurbs.get_revolved_surface( center, axis, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI, arc.knots, arc.degree, arc.control_points, arc.weights );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-225">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-225">&#182;</a>
              </div>
              <h4 id="get_polyline_curve-pts-">get_polyline_curve( pts )</h4>
<p>Generate the control points, weights, and knots of a polyline curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, array of points in curve</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_polyline_curve = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( pts )</span>{</span>

	<span class="hljs-keyword">var</span> num_spans = pts.length - <span class="hljs-number">1</span>
		, span = <span class="hljs-number">1.0</span> / num_spans
		, knots = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt; num_spans; i++){
		knots.push(i * span);
	}

	knots.push(<span class="hljs-number">1</span>);
	knots.push(<span class="hljs-number">1</span>);

	<span class="hljs-keyword">var</span> weights = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; pts.length; i++){
		weights.push(<span class="hljs-number">1</span>);
	}

	<span class="hljs-keyword">return</span> {
			<span class="hljs-string">"knots"</span>: knots, 
			<span class="hljs-string">"control_points"</span>: pts.slice(<span class="hljs-number">0</span>), 
			<span class="hljs-string">"degree"</span>: <span class="hljs-number">1</span>,
			<span class="hljs-string">"weights"</span>: weights 
		};
			
}</pre></div></div>
            
        </li>
        
        
        <li id="section-226">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-226">&#182;</a>
              </div>
              <h4 id="get_4pt_surface-p1-p2-p3-p4-">get_4pt_surface( p1, p2, p3, p4 )</h4>
<p>Generate the control points, weights, and knots of a surface define by 3 points</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, first point in counter-clockwise form</li>
<li><em>Array</em>, second point in counter-clockwise form</li>
<li><em>Array</em>, third point in counter-clockwise form</li>
<li><em>Array</em>, forth point in counter-clockwise form</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots_u, knots_v, degree_u, degree_v</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_4pt_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( p1, p2, p3, p4 )</span>{</span>

	<span class="hljs-keyword">var</span> p1p4 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p1, p4 ));
	<span class="hljs-keyword">var</span> p2p3 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p2, p3 ));
	<span class="hljs-keyword">var</span> p3p4 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p3, p4 ));
	<span class="hljs-keyword">var</span> p1p2 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p1, p2 ));
	<span class="hljs-keyword">var</span> p1p4p2p3 = numeric.mul( <span class="hljs-number">0.5</span>, numeric.add( p1p4, p2p3 ));

	<span class="hljs-keyword">return</span> {<span class="hljs-string">"knots_u"</span>: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], 
			<span class="hljs-string">"knots_v"</span>: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], 
			<span class="hljs-string">"control_points"</span>: [ [p1, 		p1p4, 		p4], 
													[p1p2, 	p1p4p2p3, p3p4], 
													[p2, 		p2p3, 		p3] ], 
			<span class="hljs-string">"degree_u"</span>: <span class="hljs-number">2</span>, 
			<span class="hljs-string">"degree_v"</span>: <span class="hljs-number">2</span>,
			<span class="hljs-string">"weights"</span>: [ [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], 
									 [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>], 
									 [ <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>] ] };
			
}</pre></div></div>
            
        </li>
        
        
        <li id="section-227">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-227">&#182;</a>
              </div>
              <h4 id="get_cylinder_surface-axis-xaxis-base-height-radius-">get_cylinder_surface( axis, xaxis, base, height, radius )</h4>
<p>Generate the control points, weights, and knots of a cylinder</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, normalized axis of cylinder</li>
<li><em>Array</em>, xaxis in plane of cylinder</li>
<li><em>Array</em>, position of base of cylinder</li>
<li><em>Number</em>, height from base to top</li>
<li><em>Number</em>, radius of the cylinder</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots_u, knots_v, degree_u, degree_v</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_cylinder_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( axis, xaxis, base, height, radius )</span>{</span>

	<span class="hljs-keyword">var</span> yaxis = crossprod( axis, xaxis )
		, angle = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI
		, circ = verb.eval.nurbs.get_arc( base, xaxis, yaxis, radius, <span class="hljs-number">0</span>, <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI );

	<span class="hljs-keyword">return</span> verb.eval.nurbs.get_extruded_surface( axis, height, circ.knots, circ.degree, circ.control_points, circ.weights );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-228">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-228">&#182;</a>
              </div>
              <h4 id="get_cone_surface-axis-xaxis-base-height-radius-">get_cone_surface( axis, xaxis, base, height, radius )</h4>
<p>Generate the control points, weights, and knots of a cone</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, normalized axis of cone</li>
<li><em>Array</em>, position of base of cone</li>
<li><em>Number</em>, height from base to tip</li>
<li><em>Number</em>, radius at the base of the cone</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_cone_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( axis, xaxis, base, height, radius )</span>{</span>

	<span class="hljs-keyword">var</span> angle = <span class="hljs-number">2</span> * <span class="hljs-built_in">Math</span>.PI
		, prof_degree = <span class="hljs-number">1</span>
		, prof_ctrl_pts = [ numeric.add( base, numeric.mul( height, axis ) ), numeric.add( base, numeric.mul( radius, xaxis ) )]
		, prof_knots = [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>]
		, prof_weights = [<span class="hljs-number">1</span>,<span class="hljs-number">1</span>];

	<span class="hljs-keyword">return</span> verb.eval.nurbs.get_revolved_surface(base, axis, angle, prof_knots, prof_degree, prof_ctrl_pts, prof_weights);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-229">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-229">&#182;</a>
              </div>
              <h4 id="get_extruded_surface-axis-length-prof_knots-prof_degree-prof_control_points-prof_weights-">get_extruded_surface( axis, length, prof_knots, prof_degree, prof_control_points, prof_weights)</h4>
<p>Generate the control points, weights, and knots of an extruded surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, axis of the extrusion</li>
<li><em>Array</em>, length of the extrusion</li>
<li><em>Number</em>, degree of the profile</li>
<li><em>Number</em>, control points of the profile</li>
<li><em>Number</em>, weights of the profile</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_extruded_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( axis, length, prof_knots, prof_degree, prof_control_points, prof_weights)</span>{</span>

	<span class="hljs-keyword">var</span> control_points = verb.eval.nurbs.zeros_2d( <span class="hljs-number">3</span>, prof_control_points.length )
		, weights = verb.eval.nurbs.zeros_2d( <span class="hljs-number">3</span>, prof_control_points.length );

	<span class="hljs-keyword">var</span> translation = numeric.mul(axis, length);
	<span class="hljs-keyword">var</span> halfTranslation = numeric.mul(axis, <span class="hljs-number">0.5</span> * length);</pre></div></div>
            
        </li>
        
        
        <li id="section-230">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-230">&#182;</a>
              </div>
              <p>original control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; prof_control_points.length; j++){
		control_points[<span class="hljs-number">0</span>][j] = prof_control_points[j];
		control_points[<span class="hljs-number">1</span>][j] = numeric.add( halfTranslation, prof_control_points[j] );
		control_points[<span class="hljs-number">2</span>][j] = numeric.add( translation, prof_control_points[j] );

		weights[<span class="hljs-number">0</span>][j] = prof_weights[j];
		weights[<span class="hljs-number">1</span>][j] = prof_weights[j];
		weights[<span class="hljs-number">2</span>][j] = prof_weights[j];
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-231">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-231">&#182;</a>
              </div>
              <p>return all parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> {<span class="hljs-string">"knots_u"</span>: [<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>], 
			<span class="hljs-string">"knots_v"</span>: prof_knots, 
			<span class="hljs-string">"control_points"</span>: control_points, 
			<span class="hljs-string">"degree_u"</span>: <span class="hljs-number">2</span>, 
			<span class="hljs-string">"degree_v"</span>: prof_degree, 
			<span class="hljs-string">"weights"</span>: weights };
}</pre></div></div>
            
        </li>
        
        
        <li id="section-232">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-232">&#182;</a>
              </div>
              <h4 id="get_revolved_surface-center-axis-theta-prof_knots-prof_degree-prof_control_points-prof_weights-">get_revolved_surface( center, axis, theta, prof_knots, prof_degree, prof_control_points, prof_weights)</h4>
<p>Generate the control points, weights, and knots of a revolved surface
(Corresponds to Algorithm A7.1 from Piegl &amp; Tiller)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, center of the rotation axis</li>
<li><em>Array</em>, axis of the rotation axis</li>
<li><em>Number</em>, angle to revolve around axis</li>
<li><em>Number</em>, degree of the generatrix</li>
<li><em>Number</em>, control points of the generatrix</li>
<li><em>Number</em>, weights of the generatrix</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>
<p>helper method</p>

            </div>
            
            <div class="content"><div class='highlight'><pre><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">crossprod</span><span class="hljs-params">(u,v)</span> {</span>
  <span class="hljs-keyword">return</span> [u[<span class="hljs-number">1</span>]*v[<span class="hljs-number">2</span>]-u[<span class="hljs-number">2</span>]*v[<span class="hljs-number">1</span>],u[<span class="hljs-number">2</span>]*v[<span class="hljs-number">0</span>]-u[<span class="hljs-number">0</span>]*v[<span class="hljs-number">2</span>],u[<span class="hljs-number">0</span>]*v[<span class="hljs-number">1</span>]-u[<span class="hljs-number">1</span>]*v[<span class="hljs-number">0</span>]];
}

verb.eval.nurbs.get_revolved_surface = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, axis, theta, prof_knots, prof_degree, prof_control_points, prof_weights)</span>{</span>

	<span class="hljs-keyword">var</span> narcs, knots_u, control_points, weights;

	<span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>) { <span class="hljs-comment">// less than 90</span>
		narcs = <span class="hljs-number">1</span>;
		knots_u = verb.eval.nurbs.zeros_1d( <span class="hljs-number">6</span> + <span class="hljs-number">2</span>  * (narcs-<span class="hljs-number">1</span>) );
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-built_in">Math</span>.PI){  <span class="hljs-comment">// between 90 and 180</span>
			narcs = <span class="hljs-number">2</span>;
			knots_u = verb.eval.nurbs.zeros_1d( <span class="hljs-number">6</span> + <span class="hljs-number">2</span> * (narcs-<span class="hljs-number">1</span>) );
			knots_u[<span class="hljs-number">3</span>]= knots_u[<span class="hljs-number">4</span>] = <span class="hljs-number">0.5</span>;
		} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (theta &lt;= <span class="hljs-number">3</span> * <span class="hljs-built_in">Math</span>.PI / <span class="hljs-number">2</span>){ <span class="hljs-comment">// between 180 and 270</span>
			narcs = <span class="hljs-number">3</span>;
			knots_u = verb.eval.nurbs.zeros_1d( <span class="hljs-number">6</span> + <span class="hljs-number">2</span> * (narcs-<span class="hljs-number">1</span>) );
			knots_u[<span class="hljs-number">3</span>]= knots_u[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>/<span class="hljs-number">3</span>;
			knots_u[<span class="hljs-number">5</span>]= knots_u[<span class="hljs-number">6</span>] = <span class="hljs-number">2</span>/<span class="hljs-number">3</span>;
		} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// between 270 and 360</span>
			narcs = <span class="hljs-number">4</span>;
			knots_u = verb.eval.nurbs.zeros_1d( <span class="hljs-number">6</span> + <span class="hljs-number">2</span> * (narcs-<span class="hljs-number">1</span>) );
			knots_u[<span class="hljs-number">3</span>]= knots_u[<span class="hljs-number">4</span>] = <span class="hljs-number">1</span>/<span class="hljs-number">4</span>;
			knots_u[<span class="hljs-number">5</span>]= knots_u[<span class="hljs-number">6</span>] = <span class="hljs-number">1</span>/<span class="hljs-number">2</span>;
			knots_u[<span class="hljs-number">7</span>]= knots_u[<span class="hljs-number">8</span>] = <span class="hljs-number">3</span>/<span class="hljs-number">4</span>;
		}
	}

	<span class="hljs-keyword">var</span> dtheta = theta / narcs <span class="hljs-comment">// divide the interval into several points</span>
		, j = <span class="hljs-number">3</span> + <span class="hljs-number">2</span> * (narcs-<span class="hljs-number">1</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-233">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-233">&#182;</a>
              </div>
              <p>initialize the start and end knots
keep in mind that we only return the knot vector for the </p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">3</span>; j++, i++){
		knots_u[i] = <span class="hljs-number">0.0</span>;
		knots_u[j] = <span class="hljs-number">1.0</span>;
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-234">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-234">&#182;</a>
              </div>
              <p>do some initialization</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> n = <span class="hljs-number">2</span> * narcs 
		, wm = <span class="hljs-built_in">Math</span>.cos( dtheta/<span class="hljs-number">2.0</span> )
		, angle = <span class="hljs-number">0.0</span>
		, sines = verb.eval.nurbs.zeros_1d( narcs + <span class="hljs-number">1</span>)
		, cosines = verb.eval.nurbs.zeros_1d( narcs + <span class="hljs-number">1</span>)
		, control_points = verb.eval.nurbs.zeros_2d( <span class="hljs-number">2</span>*narcs + <span class="hljs-number">1</span>, prof_control_points.length )
		, weights = verb.eval.nurbs.zeros_2d( <span class="hljs-number">2</span>*narcs + <span class="hljs-number">1</span>, prof_control_points.length );</pre></div></div>
            
        </li>
        
        
        <li id="section-235">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-235">&#182;</a>
              </div>
              <p>initialize the sines and cosines</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= narcs; i++){
		angle += dtheta;
		cosines[i] = <span class="hljs-built_in">Math</span>.cos(angle);
		sines[i] = <span class="hljs-built_in">Math</span>.sin(angle);
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-236">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-236">&#182;</a>
              </div>
              <p>for each pt in the generatrix
i.e. for each row of the 2d knot vectors</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt; prof_control_points.length; j++){</pre></div></div>
            
        </li>
        
        
        <li id="section-237">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-237">&#182;</a>
              </div>
              <p>get the closest point of the generatrix point on the axis</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> O = verb.eval.geom.closest_point_on_ray(prof_control_points[j], center, axis)</pre></div></div>
            
        </li>
        
        
        <li id="section-238">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-238">&#182;</a>
              </div>
              <p>X is the vector from the axis to generatrix control pt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, X = numeric.sub( prof_control_points[j], O )</pre></div></div>
            
        </li>
        
        
        <li id="section-239">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-239">&#182;</a>
              </div>
              <p>radius at that height</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, r = numeric.norm2(X)</pre></div></div>
            
        </li>
        
        
        <li id="section-240">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-240">&#182;</a>
              </div>
              <p>Y is perpendicular to X and axis, and complete the coordinate system</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			, Y = crossprod(axis,X); 

		<span class="hljs-keyword">if</span> ( r &gt; verb.EPSILON ){
			X = numeric.mul( <span class="hljs-number">1</span> / r, X);
			Y = numeric.mul( <span class="hljs-number">1</span> / r, Y);
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-241">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-241">&#182;</a>
              </div>
              <p>the first row of control_points and weights is just the generatrix</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		control_points[<span class="hljs-number">0</span>][j] = prof_control_points[j];
		<span class="hljs-keyword">var</span> P0 = prof_control_points[j];
		weights[<span class="hljs-number">0</span>][j] = prof_weights[j];</pre></div></div>
            
        </li>
        
        
        <li id="section-242">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-242">&#182;</a>
              </div>
              <p>store T0 as the Y vector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">var</span> T0 = Y
			, index = <span class="hljs-number">0</span>
			, angle = <span class="hljs-number">0.0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-243">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-243">&#182;</a>
              </div>
              <p>proceed around the circle</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= narcs; i++){</pre></div></div>
            
        </li>
        
        
        <li id="section-244">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-244">&#182;</a>
              </div>
              <p>O + r <em> cos(theta) </em> X + r <em> sin(theta) </em> Y
rotated generatrix pt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> P2 = r == <span class="hljs-number">0</span> ? O : numeric.add( O, numeric.mul( r, cosines[i], X), numeric.mul( r, sines[i], Y) );

			control_points[index+<span class="hljs-number">2</span>][j] = P2;
			weights[index+<span class="hljs-number">2</span>][j] = prof_weights[j];</pre></div></div>
            
        </li>
        
        
        <li id="section-245">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-245">&#182;</a>
              </div>
              <p>construct the vector tangent to the rotation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">var</span> T2 = numeric.sub( numeric.mul( cosines[i], Y), numeric.mul(sines[i], X));</pre></div></div>
            
        </li>
        
        
        <li id="section-246">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-246">&#182;</a>
              </div>
              <p>construct the next control pt</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			<span class="hljs-keyword">if</span> (r == <span class="hljs-number">0</span>){
				control_points[index+<span class="hljs-number">1</span>][j] = O;
			} <span class="hljs-keyword">else</span> {
				<span class="hljs-keyword">var</span> params = verb.eval.geom.intersect_rays(P0, numeric.mul( <span class="hljs-number">1</span> / numeric.norm2(T0), T0), P2, numeric.mul( <span class="hljs-number">1</span> / numeric.norm2(T2), T2));
				<span class="hljs-keyword">var</span> P1 = numeric.add( P0, numeric.mul(T0, params[<span class="hljs-number">0</span>]));

				control_points[index+<span class="hljs-number">1</span>][j] = P1;
			}

			weights[index+<span class="hljs-number">1</span>][j] = wm * prof_weights[j];

			index += <span class="hljs-number">2</span>;

			<span class="hljs-keyword">if</span> (i &lt; narcs)
			{
				P0 = P2;
				T0 = T2;
			}

		}
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-247">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-247">&#182;</a>
              </div>
              <p>store all of the parameters</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">return</span> {<span class="hljs-string">"knots_u"</span>: knots_u, 
			<span class="hljs-string">"knots_v"</span>: prof_knots, 
			<span class="hljs-string">"control_points"</span>: control_points, 
			<span class="hljs-string">"degree_u"</span>: <span class="hljs-number">2</span>, 
			<span class="hljs-string">"degree_v"</span>: prof_degree, 
			<span class="hljs-string">"weights"</span>: weights };

}</pre></div></div>
            
        </li>
        
        
        <li id="section-248">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-248">&#182;</a>
              </div>
              <h4 id="get_arc-center-xaxis-yaxis-radius-start_angle-end_angle-">get_arc( center, xaxis, yaxis, radius, start_angle, end_angle )</h4>
<p>Generate the control points, weights, and knots of an arbitrary arc
(Corresponds to Algorithm A7.1 from Piegl &amp; Tiller)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, the center of the arc</li>
<li><em>Array</em>, the xaxis of the arc</li>
<li><em>Array</em>, orthogonal yaxis of the arc</li>
<li><em>Number</em>, radius of the arc</li>
<li><em>Number</em>, start angle of the arc, between 0 and 2pi</li>
<li><em>Number</em>, end angle of the arc, between 0 and 2pi, greater than the start angle</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Object</em>, an object with the following properties: control_points, weights, knots, degree</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.get_arc = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( center, xaxis, yaxis, radius, start_angle, end_angle )</span> {</span>

	<span class="hljs-keyword">return</span> verb.eval.nurbs.get_ellipse_arc( center, xaxis, yaxis, radius, radius, start_angle, end_angle );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-249">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-249">&#182;</a>
              </div>
              <h4 id="surface_curvature-degree_u-knots_u-degree_v-knots_v-control_points-u-v-options-">surface_curvature( degree_u, knots_u, degree_v, knots_v, control_points, u, v, options )</h4>
<p>Compute the gaussian curvature on a non-uniform, non-rational B spline surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run alonsg the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_surface_curvature = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, u, v )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-250">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-250">&#182;</a>
              </div>
              <p>second fundamental form (shape operator)</p>
<p>symmetric matrix where</p>
<p>II = [ L M; M N ]</p>
<p>where:</p>
<p>L = Xuu <em> n
M = Xuv </em> n
N = Xvv * n</p>
<p>principal curvatures are the eigenvalues of the second fundamental form</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> derivs = verb.eval.nurbs.rational_surface_derivs( 	degree_u, 
																													knots_u, 
																													degree_v, 
																													knots_v, 
																													homo_control_points, 
																													<span class="hljs-number">2</span>, u, v );</pre></div></div>
            
        </li>
        
        
        <li id="section-251">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-251">&#182;</a>
              </div>
              <p>structure of the derivatives</p>
<p>pos  du  vuu 
dv   duv 
dvv </p>

            </div>
            
            <div class="content"><div class='highlight'><pre> 
  <span class="hljs-keyword">var</span> du = derivs[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];
  <span class="hljs-keyword">var</span> dv = derivs[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> duu = derivs[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>];
  <span class="hljs-keyword">var</span> dvv = derivs[<span class="hljs-number">2</span>][<span class="hljs-number">0</span>];
  <span class="hljs-keyword">var</span> duv = derivs[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>];

  <span class="hljs-keyword">var</span> n = numeric.cross( du, dv );
  <span class="hljs-keyword">var</span> L = numeric.dot( duu, n );
  <span class="hljs-keyword">var</span> M = numeric.dot( duv, n );
  <span class="hljs-keyword">var</span> N = numeric.dot( dvv, n );

  <span class="hljs-keyword">var</span> shapeOperator = [ [ L, M ], [ M, N ] ];

	<span class="hljs-keyword">var</span> eigs = numeric.eig( shapeOperator );</pre></div></div>
            
        </li>
        
        
        <li id="section-252">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-252">&#182;</a>
              </div>
              <p>contains: lambda - x
                 E - x</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	
	<span class="hljs-keyword">var</span> k1 = eigs.lambda.x[<span class="hljs-number">0</span>];
	<span class="hljs-keyword">var</span> k2 = eigs.lambda.x[<span class="hljs-number">1</span>];
	<span class="hljs-keyword">var</span> mean = <span class="hljs-number">0.5</span> * ( k1 + k2 );
	<span class="hljs-keyword">var</span> gaussian = k1 * k2;
	<span class="hljs-keyword">var</span> p1 = numeric.add( numeric.mul( eigs.E.x[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], du ), numeric.mul( eigs.E.x[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], dv ) );
	<span class="hljs-keyword">var</span> p2 = numeric.add( numeric.mul( eigs.E.x[<span class="hljs-number">1</span>][<span class="hljs-number">0</span>], du ), numeric.mul( eigs.E.x[<span class="hljs-number">1</span>][<span class="hljs-number">1</span>], dv ) );

	<span class="hljs-keyword">return</span> { point: derivs[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], normal: n, mean: mean, gaussian: gaussian, shapeOperator: shapeOperator, k1: k1, k2: k2, p1: p1, p2: p2, p1p : eigs.E.x[<span class="hljs-number">0</span>], p2p: eigs.E.x[<span class="hljs-number">1</span>]  };

};</pre></div></div>
            
        </li>
        
        
        <li id="section-253">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-253">&#182;</a>
              </div>
              <h4 id="curve_knot_insert-degree-knots-control_points-u-s-r-">curve_knot_insert( degree, knots, control_points, u, s, r )</h4>
<p>Insert a knot along a rational curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
<li><em>Array</em>, 1d array of control point weights </li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_knot_insert = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, u, s, r )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-254">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-254">&#182;</a>
              </div>
              <p>np is n for the initial curve
nq is n for the output curve with knots inserted
k is the span on which the knots are inserted
s is the initial multiplicity of the point
r is the number of times to insert the knot
control_points is initial set of control points</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> dim = control_points[<span class="hljs-number">0</span>].length
		, np = knots.length - degree - <span class="hljs-number">2</span>
		, num_pts = control_points.length
		, k = verb.eval.nurbs.knot_span( degree, u, knots )
		, mp = np + degree + <span class="hljs-number">1</span>
		, nq = np + r
		, num_pts_post = num_pts + r    
		, Rw = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( degree + <span class="hljs-number">1</span> )  
		, knots_post = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( knots.length + r ) 
		, control_points_post = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( num_pts_post ) 
		, i = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-255">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-255">&#182;</a>
              </div>
              <p>new knot vector</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= k; i++) {
		knots_post[i] = knots[i];
	}
	
	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= r; i++) {
		knots_post[k+i] = u; 
	}

	<span class="hljs-keyword">for</span> (i = k+<span class="hljs-number">1</span>; i &lt;= mp; i++)
	{
		knots_post[i+r] = knots[i];
	}</pre></div></div>
            
        </li>
        
        
        <li id="section-256">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-256">&#182;</a>
              </div>
              <p>control point generation</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= k-degree; i++)
	{
		control_points_post[i] = control_points[i]; 
	}

	<span class="hljs-keyword">for</span> (i = k-s; i &lt;= np; i++)
	{
		control_points_post[i+r] = control_points[i];
	}

	<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= degree-s; i++)
	{
		Rw[i] = control_points[k-degree+<span class="hljs-number">1</span>];
	}

	<span class="hljs-keyword">var</span> L = <span class="hljs-number">0</span>
		, alpha = <span class="hljs-number">0</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-257">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-257">&#182;</a>
              </div>
              <p>insert knot r times</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;= r; j++) {

		L = k-degree+j;

		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt;= degree-j-s; i++) {

			alpha = ( u - knots[L+i] ) / ( knots[i+k+<span class="hljs-number">1</span>] - knots[L+i] );
			Rw[i] = numeric.add( numeric.mul( alpha, Rw[i+<span class="hljs-number">1</span>] ), numeric.mul( (<span class="hljs-number">1.0</span> - alpha), Rw[i]) );

		}

		control_points_post[ L ] = Rw[<span class="hljs-number">0</span>];
		control_points_post[k+r-j-s] = Rw[degree-j-s];

	}</pre></div></div>
            
        </li>
        
        
        <li id="section-258">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-258">&#182;</a>
              </div>
              <p>not so confident about this part</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">for</span> (i = L+<span class="hljs-number">1</span>; i &lt; k-s; i++) <span class="hljs-comment">// set remaining control points</span>
	{
		control_points_post[i] = Rw[ i - L ];
	}

	<span class="hljs-keyword">return</span> [knots_post, control_points_post];

}</pre></div></div>
            
        </li>
        
        
        <li id="section-259">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-259">&#182;</a>
              </div>
              <h4 id="rational_surface_derivs-degree_u-knots_u-degree_v-knots_v-homo_control_points-num_derivs-u-v-">rational_surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, num_derivs, u, v)</h4>
<p>Compute the derivatives at a point on a NURBS surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
<li><em>Array</em>, 1d array of control point weights </li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_surface_derivs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, homo_control_points, num_derivs, u, v)</span> {</span>

	<span class="hljs-keyword">var</span> SKL_homo = verb.eval.nurbs.surface_derivs( degree_u, knots_u, degree_v, knots_v, homo_control_points, num_derivs, u, v )
		, ders = verb.eval.nurbs.separate_homo_derivs_2d( SKL_homo )
		, Aders = ders[<span class="hljs-number">0</span>]
		, wders = ders[<span class="hljs-number">1</span>]
		, k = <span class="hljs-number">0</span>
		, i  = <span class="hljs-number">0</span>
		, j = <span class="hljs-number">0</span>
		, l = <span class="hljs-number">0</span>
		, SKL = []
		, dim = Aders[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length;

	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= num_derivs; k++) {
		SKL.push([]);

		<span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= num_derivs-k; l++) {

			<span class="hljs-keyword">var</span> v = Aders[k][l];
			<span class="hljs-keyword">for</span> (j=<span class="hljs-number">1</span>; j &lt;= l; j++) {
				v = numeric.sub( v, numeric.mul( numeric.mul( binomial.get(l, j), wders[<span class="hljs-number">0</span>][j] ), SKL[k][l-j] ) );
			}

			<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= k; i++) {
				v = numeric.sub( v, numeric.mul( numeric.mul( binomial.get(k, i), wders[i][<span class="hljs-number">0</span>] ), SKL[k-i][l] ) );
				
				<span class="hljs-keyword">var</span> v2 = verb.eval.nurbs.zeros_1d(dim);

				<span class="hljs-keyword">for</span> (j = <span class="hljs-number">1</span>; j &lt;= l; j++) {
					v2 = numeric.add( v2, numeric.mul( numeric.mul( binomial.get(l, j), wders[i][j] ), SKL[k-i][l-j] ) );
				}

				v = numeric.sub( v, numeric.mul( binomial.get(k, i), v2) );

			}
			SKL[k].push( numeric.mul(<span class="hljs-number">1</span>/wders[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], v )); <span class="hljs-comment">// demogenize</span>

		}
	}

	<span class="hljs-keyword">return</span> SKL;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-260">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-260">&#182;</a>
              </div>
              <h4 id="rational_surface_point-degree_u-knots_u-degree_v-knots_v-homo_control_points-u-v-">rational_surface_point( degree_u, knots_u,  degree_v, knots_v, homo_control_points, u, v )</h4>
<p>Compute a point on a NURBS surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points (tensor), top to bottom is increasing u direction, left to right is increasing v direction,
and where each control point is an array of length (dim+1)</li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_surface_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u,  degree_v, knots_v, homo_control_points, u, v )</span> {</span>

	<span class="hljs-keyword">return</span> verb.eval.nurbs.dehomogenize( verb.eval.nurbs.surface_point( degree_u, knots_u,  degree_v, knots_v, homo_control_points, u, v ) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-261">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-261">&#182;</a>
              </div>
              <p>`</p>
<h4 id="rational_curve_derivs-degree-knots-homo_control_points-u-num_derivs-">rational_curve_derivs( degree, knots, homo_control_points, u, num_derivs )</h4>
<p>Determine the derivatives of a NURBS curve at a given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) and form (wi*pi, wi)</li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_derivs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, homo_control_points, u, num_derivs )</span> {</span></pre></div></div>
            
        </li>
        
        
        <li id="section-262">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-262">&#182;</a>
              </div>
              <p>compute the derivatives of the control points
separate derivative array into two</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>	<span class="hljs-keyword">var</span> ders = verb.eval.nurbs.separate_homo_derivs_1d( verb.eval.nurbs.curve_derivs( degree, knots, homo_control_points, u, num_derivs ) )
		, Aders = ders[<span class="hljs-number">0</span>]
		, wders = ders[<span class="hljs-number">1</span>]
		, k = <span class="hljs-number">0</span>
		, i  = <span class="hljs-number">0</span>
		, CK = [];

	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= num_derivs; k++) {
		<span class="hljs-keyword">var</span> v = Aders[k];

		<span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt;= k; i++) {
			v = numeric.sub( v, numeric.mul( numeric.mul( binomial.get(k, i), wders[i] ), CK[k-i] ) );
		}
		CK.push( numeric.mul(<span class="hljs-number">1</span>/wders[<span class="hljs-number">0</span>], v )); <span class="hljs-comment">// demogenize</span>
	}

	<span class="hljs-keyword">return</span> CK;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-263">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-263">&#182;</a>
              </div>
              <h4 id="separate_homo_derivs_1d-ck-">separate_homo_derivs_1d( ck )</h4>
<p>Separate the array of derivatives into the A(u) component and w(u), i.e. the weight and everything else without dehomogenization</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 1d array of homogeneous derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array with Aders and wders as element 0 and 1, respectively</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.separate_homo_derivs_1d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( CK )</span> {</span>

	<span class="hljs-keyword">var</span> dim = CK[<span class="hljs-number">0</span>].length
		, last = dim-<span class="hljs-number">1</span>
		, Aders = []
		, wders = [];

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = CK.length; i &lt; l; i++ ) {
		Aders.push( CK[i].slice(<span class="hljs-number">0</span>, last) );
		wders.push( CK[i][last] );
	}

	<span class="hljs-keyword">return</span> [Aders, wders];

};</pre></div></div>
            
        </li>
        
        
        <li id="section-264">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-264">&#182;</a>
              </div>
              <h4 id="separate_homo_derivs_2d-skl-">separate_homo_derivs_2d( skl )</h4>
<p>Separate the array of derivatives into the A(u) component and w(u), i.e. the weight and everything else without dehomogenization</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 2d array of homogeneous derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, an array with Aders and wders as element 0 and 1, respectively</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.separate_homo_derivs_2d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( SKL )</span> {</span>

	<span class="hljs-keyword">var</span> Aders = []
		, wders = [];

	<span class="hljs-keyword">for</span> ( <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, l = SKL.length; i &lt; l; i++ ) {
		<span class="hljs-keyword">var</span> CK = verb.eval.nurbs.separate_homo_derivs_1d( SKL[i] );
		Aders.push( CK[<span class="hljs-number">0</span>] );
		wders.push( CK[<span class="hljs-number">1</span>] );
	}

	<span class="hljs-keyword">return</span> [Aders, wders];

};</pre></div></div>
            
        </li>
        
        
        <li id="section-265">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-265">&#182;</a>
              </div>
              <h4 id="rational_curve_point-degree-knots-homo_control_points-u-">rational_curve_point( degree, knots, homo_control_points, u)</h4>
<p>Compute a point on a NURBS curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of homogeneous control points, where each control point is an array of length (dim+1) 
and form (wi*pi, wi)</li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.rational_curve_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, homo_control_points, u)</span> {</span>

	<span class="hljs-keyword">return</span> verb.eval.nurbs.dehomogenize( verb.eval.nurbs.curve_point( degree, knots, homo_control_points, u) );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-266">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-266">&#182;</a>
              </div>
              <h4 id="dehomogenize-homo_point-">dehomogenize( homo_point )</h4>
<p>Dehomogenize a point </p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, a point represented by an array (wi*pi, wi) with length (dim+1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array pi with length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.dehomogenize = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( homo_point )</span> {</span>

	<span class="hljs-keyword">var</span> dim = homo_point.length
		, point = []
		, wt = homo_point[dim-<span class="hljs-number">1</span>];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; homo_point.length-<span class="hljs-number">1</span>;i++)
		point.push( homo_point[i] / wt );

	<span class="hljs-keyword">return</span> point;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-267">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-267">&#182;</a>
              </div>
              <h4 id="homogenize_1d-control_points-weights-">homogenize_1d( control_points, weights)</h4>
<p>Transform a 1d array of points into their homogeneous equivalents</p>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 1d array of control points, (actually a 2d array of size (m x dim) )</li>
<li><em>Array</em>, array of control point weights, the same size as the array of control points (m x 1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 1d array of control points where each point is (wi*pi, wi) where wi 
i the ith control point weight and pi is the ith control point, 
hence the dimension of the point is dim + 1</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.homogenize_1d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( control_points, weights)</span> {</span>

	<span class="hljs-keyword">var</span> rows = control_points.length
		, dim = control_points[<span class="hljs-number">0</span>].length
		, k = <span class="hljs-number">0</span>
		, homo_control_points = []
		, wt = <span class="hljs-number">0</span>
		, ref_pt = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) {

		<span class="hljs-keyword">var</span> pt = [];
		ref_pt = control_points[i];
		wt = weights[i];

		<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt; dim; k++) {
			pt.push( ref_pt[k] * wt );
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-268">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-268">&#182;</a>
              </div>
              <p>append the weight</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		pt.push(wt);

		homo_control_points.push(pt);
	}

	<span class="hljs-keyword">return</span> homo_control_points;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-269">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-269">&#182;</a>
              </div>
              <h4 id="homogenize_2d-control_points-weights-">homogenize_2d( control_points, weights)</h4>
<p><strong>params</strong></p>
<ul>
<li><em>Array</em>, 2d array of control points, (actually a 3d array of size m x n x dim)</li>
<li><em>Array</em>, array of control point weights, the same size as the control points array (m x n x 1)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 1d array of control points where each point is (wi*pi, wi) where wi 
i the ith control point weight and pi is the ith control point, the size is 
(m x n x dim+1)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.homogenize_2d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( control_points, weights)</span> {</span>

	<span class="hljs-keyword">var</span> rows = control_points.length
		, cols = control_points[<span class="hljs-number">0</span>].length
		, dim = control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length
		, j = <span class="hljs-number">0</span>
		, k = <span class="hljs-number">0</span>
		, homo_control_points = []
		, wt = <span class="hljs-number">0</span>
		, ref_pt = [];

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; rows; i++) {
		homo_control_points.push( verb.eval.nurbs.homogenize_1d(control_points[i], weights[i]) );
	}

	<span class="hljs-keyword">return</span> homo_control_points;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-270">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-270">&#182;</a>
              </div>
              <h4 id="surface_derivs-degree_u-knots_u-degree_v-knots_v-control_points-num_derivatives-u-v-">surface_derivs( degree_u, knots_u, degree_v, knots_v, control_points, num_derivatives, u, v )</h4>
<p>Compute the derivatives on a non-uniform, non-rational B spline surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.surface_derivs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, control_points, num_derivatives, u, v )</span> {</span>

	<span class="hljs-keyword">var</span> n = knots_u.length - degree_u - <span class="hljs-number">2</span>
		, m = knots_v.length - degree_v - <span class="hljs-number">2</span>;

	<span class="hljs-keyword">return</span> verb.eval.nurbs.surface_derivs_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, num_derivatives, u, v );

};</pre></div></div>
            
        </li>
        
        
        <li id="section-271">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-271">&#182;</a>
              </div>
              <h4 id="surface_derivs_given_n_m-n-degree_u-knots_u-m-degree_v-knots_v-control_points-num_derivatives-u-v-">surface_derivs_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, num_derivatives, u, v )</h4>
<p>Compute the derivatives on a non-uniform, non-rational B spline surface 
(corresponds to algorithm 3.6 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer number of basis functions in v dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the derivatives</li>
<li><em>Number</em>, v parameter at which to evaluate the derivatives</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.surface_derivs_given_n_m = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree_u, knots_u, m, degree_v, knots_v, control_points, num_derivatives, u, v )</span> {</span>

	<span class="hljs-keyword">if</span> ( verb.eval.nurbs.are_valid_relations(degree_u, control_points.length, knots_u.length ) === <span class="hljs-literal">false</span> ||
		verb.eval.nurbs.are_valid_relations(degree_v, control_points[<span class="hljs-number">0</span>].length, knots_v.length ) === <span class="hljs-literal">false</span> ) {
		console.error(<span class="hljs-string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> dim = control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length
		, du = <span class="hljs-built_in">Math</span>.min(num_derivatives, degree_u)
		, dv = <span class="hljs-built_in">Math</span>.min(num_derivatives, degree_v)
		, SKL = verb.eval.nurbs.zeros_3d( du+<span class="hljs-number">1</span>, dv+<span class="hljs-number">1</span>, dim )
		, knot_span_index_u = verb.eval.nurbs.knot_span_given_n( n, degree_u, u, knots_u )
		, knot_span_index_v = verb.eval.nurbs.knot_span_given_n( m, degree_v, v, knots_v )
		, uders = verb.eval.nurbs.deriv_basis_functions_given_n_i( knot_span_index_u, u, degree_u, n, knots_u )  
		, vders = verb.eval.nurbs.deriv_basis_functions_given_n_i( knot_span_index_v, v, degree_v, m, knots_v )
		, temp = verb.eval.nurbs.zeros_2d( degree_v+<span class="hljs-number">1</span>, dim )
		, k = <span class="hljs-number">0</span>
		, s = <span class="hljs-number">0</span>
		, r = <span class="hljs-number">0</span>
		, l = <span class="hljs-number">0</span>
		, dd = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= du; k++) {	
		<span class="hljs-keyword">for</span> (s = <span class="hljs-number">0</span>; s &lt;= degree_v; s++) {		
			temp[s] = verb.eval.nurbs.zeros_1d( dim );

			<span class="hljs-keyword">for</span> (r = <span class="hljs-number">0</span>; r &lt;= degree_u; r++) {	
				temp[s] = numeric.add( temp[s], numeric.mul( uders[k][r], control_points[knot_span_index_u-degree_u+r][knot_span_index_v-degree_v+s]) );
			}
		}

		dd = <span class="hljs-built_in">Math</span>.min(num_derivatives-k, dv);

		<span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= dd; l++) {	
			SKL[k][l] = verb.eval.nurbs.zeros_1d( dim );

			<span class="hljs-keyword">for</span> (s = <span class="hljs-number">0</span>; s &lt;= degree_v; s++) {	
				SKL[k][l] = numeric.add( SKL[k][l], numeric.mul( vders[l][s], temp[s] ) );
			}
		}
	}

	<span class="hljs-keyword">return</span> SKL;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-272">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-272">&#182;</a>
              </div>
              <h4 id="surface_point-degree_u-knots_u-degree_v-knots_v-control_points-u-v-">surface_point( degree_u, knots_u, degree_v, knots_v, control_points, u, v)</h4>
<p>Compute a point on a non-uniform, non-rational B-spline surface</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.surface_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, control_points, u, v)</span> {</span>

	<span class="hljs-keyword">var</span> n = knots_u.length - degree_u - <span class="hljs-number">2</span>
		, m = knots_v.length - degree_v - <span class="hljs-number">2</span>;

	<span class="hljs-keyword">return</span> 	verb.eval.nurbs.surface_point_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, u, v );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-273">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-273">&#182;</a>
              </div>
              <h4 id="volume_point-degree_u-knots_u-degree_v-knots_v-degree_w-knots_w-control_points-u-v-w-">volume_point( degree_u, knots_u, degree_v, knots_v, degree_w, knots_w, control_points, u, v, w  )</h4>
<p>Compute a point in a non-uniform, non-rational B spline volume</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of volume in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer number of basis functions in v dir - 1 = knots_v.length - degree_v - 2</li>
<li><em>Number</em>, integer degree of volume in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Number</em>, integer number of basis functions in w dir - 1 = knots_w.length - degree_w - 2</li>
<li><em>Number</em>, integer degree of volume in w direction</li>
<li><em>Array</em>, array of nondecreasing knot values in w direction</li>
<li><em>Array</em>, 4d array of control points where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the volume point</li>
<li><em>Number</em>, v parameter at which to evaluate the volume point</li>
<li><em>Number</em>, w parameter at which to evaluate the volume point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.volume_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree_u, knots_u, degree_v, knots_v, degree_w, knots_w, control_points, u, v, w )</span> {</span>

	<span class="hljs-keyword">var</span> n = knots_u.length - degree_u - <span class="hljs-number">2</span>
		, m = knots_v.length - degree_v - <span class="hljs-number">2</span>
		, l = knots_w.length - degree_w - <span class="hljs-number">2</span>;

	<span class="hljs-keyword">return</span> verb.eval.nurbs.volume_point_given_n_m_l( n, degree_u, knots_u, m, degree_v, knots_v, l, degree_w, knots_w, control_points, u, v, w );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-274">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-274">&#182;</a>
              </div>
              <h4 id="volume_point_given_n_m_l-n-degree_u-knots_u-m-degree_v-knots_v-l-degree_w-knots_w-control_points-u-v-w-">volume_point_given_n_m_l( n, degree_u, knots_u, m, degree_v, knots_v, l, degree_w, knots_w, control_points, u, v, w )</h4>
<p>Compute a point in a non-uniform, non-rational B spline volume</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of volume in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer number of basis functions in v dir - 1 = knots_v.length - degree_v - 2</li>
<li><em>Number</em>, integer degree of volume in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Number</em>, integer number of basis functions in w dir - 1 = knots_w.length - degree_w - 2</li>
<li><em>Number</em>, integer degree of volume in w direction</li>
<li><em>Array</em>, array of nondecreasing knot values in w direction</li>
<li><em>Array</em>, 4d array of control points where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the volume point</li>
<li><em>Number</em>, v parameter at which to evaluate the volume point</li>
<li><em>Number</em>, w parameter at which to evaluate the volume point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.volume_point_given_n_m_l = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree_u, knots_u, m, degree_v, knots_v, l, degree_w, knots_w, control_points, u, v, w )</span> {</span>

	<span class="hljs-keyword">if</span> ( 	!verb.eval.nurbs.are_valid_relations(degree_u, control_points.length, knots_u.length ) ||
				!verb.eval.nurbs.are_valid_relations(degree_v, control_points[<span class="hljs-number">0</span>].length, knots_v.length ) || 
				!verb.eval.nurbs.are_valid_relations(degree_w, control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length, knots_w.length ) ) {
		console.error(<span class="hljs-string">'Invalid relations between control points and knot vector'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> dim = control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length
		, knot_span_index_u = verb.eval.nurbs.knot_span_given_n( n, degree_u, u, knots_u )
		, knot_span_index_v = verb.eval.nurbs.knot_span_given_n( m, degree_v, v, knots_v )
		, knot_span_index_w = verb.eval.nurbs.knot_span_given_n( l, degree_w, w, knots_w )
		, u_basis_vals = verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index_u, u, degree_u, knots_u )
		, v_basis_vals = verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index_v, v, degree_v, knots_v )
		, w_basis_vals = verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index_w, w, degree_w, knots_w )
		, uind = knot_span_index_u - degree_u
		, vind = knot_span_index_v
		, wind = knot_span_index_w
		, position = verb.eval.nurbs.zeros_1d( dim )
		, temp = verb.eval.nurbs.zeros_1d( dim )
		, temp2 = verb.eval.nurbs.zeros_1d( dim )
		, j = <span class="hljs-number">0</span>
		, k = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt;= degree_w; i++){

		temp2 = verb.eval.nurbs.zeros_1d( dim );
		wind = knot_span_index_w - degree_w + i;

		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= degree_v; j++) {	

			temp = verb.eval.nurbs.zeros_1d( dim );
			vind = knot_span_index_v  - degree_v + j;

			<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= degree_u; k++) {</pre></div></div>
            
        </li>
        
        
        <li id="section-275">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-275">&#182;</a>
              </div>
              <p>sample u isoline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>				temp = numeric.add( temp, 
														numeric.mul( u_basis_vals[k], control_points[uind+k][vind][wind] ));
			}</pre></div></div>
            
        </li>
        
        
        <li id="section-276">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-276">&#182;</a>
              </div>
              <p>add weighted contribution of u isoline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>			temp2 = numeric.add( temp2, 
													numeric.mul( v_basis_vals[j], temp ) );
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-277">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-277">&#182;</a>
              </div>
              <p>add weighted contribution from uv isosurfaces</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		position = numeric.add( position, 
														numeric.mul( w_basis_vals[i], temp2 ) );

	}

	<span class="hljs-keyword">return</span> position;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-278">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-278">&#182;</a>
              </div>
              <h4 id="surface_point_given_n_m-n-degree_u-knots_u-m-degree_v-knots_v-control_points-u-v-">surface_point_given_n_m( n, degree_u, knots_u, m, degree_v, knots_v, control_points, u, v )</h4>
<p>Compute a point on a non-uniform, non-rational B spline surface
(corresponds to algorithm 3.5 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions in u dir - 1 = knots_u.length - degree_u - 2</li>
<li><em>Number</em>, integer degree of surface in u direction</li>
<li><em>Array</em>, array of nondecreasing knot values in u direction</li>
<li><em>Number</em>, integer degree of surface in v direction</li>
<li><em>Array</em>, array of nondecreasing knot values in v direction</li>
<li><em>Array</em>, 3d array of control points, where rows are the u dir, and columns run along the positive v direction, 
and where each control point is an array of length (dim)  </li>
<li><em>Number</em>, u parameter at which to evaluate the surface point</li>
<li><em>Number</em>, v parameter at which to evaluate the surface point</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.surface_point_given_n_m = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree_u, knots_u, m, degree_v, knots_v, control_points, u, v )</span> {</span>

	<span class="hljs-keyword">if</span> ( verb.eval.nurbs.are_valid_relations(degree_u, control_points.length, knots_u.length ) === <span class="hljs-literal">false</span> ||
		verb.eval.nurbs.are_valid_relations(degree_v, control_points[<span class="hljs-number">0</span>].length, knots_v.length ) === <span class="hljs-literal">false</span> ) {
		console.error(<span class="hljs-string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> dim = control_points[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>].length
		, knot_span_index_u = verb.eval.nurbs.knot_span_given_n( n, degree_u, u, knots_u )
		, knot_span_index_v = verb.eval.nurbs.knot_span_given_n( m, degree_v, v, knots_v )
		, u_basis_vals = verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index_u, u, degree_u, knots_u )
		, v_basis_vals = verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index_v, v, degree_v, knots_v )
		, uind = knot_span_index_u - degree_u
		, vind = knot_span_index_v
		, position = verb.eval.nurbs.zeros_1d( dim )
		, temp = verb.eval.nurbs.zeros_1d( dim )
		, l = <span class="hljs-number">0</span>
		, k = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (l = <span class="hljs-number">0</span>; l &lt;= degree_v; l++) {	

		temp = verb.eval.nurbs.zeros_1d( dim );
		vind = knot_span_index_v - degree_v + l;</pre></div></div>
            
        </li>
        
        
        <li id="section-279">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-279">&#182;</a>
              </div>
              <p>sample u isoline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= degree_u; k++) {	
			temp = numeric.add( temp, numeric.mul( u_basis_vals[k], control_points[uind+k][vind]) );
		}</pre></div></div>
            
        </li>
        
        
        <li id="section-280">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-280">&#182;</a>
              </div>
              <p>add point from u isoline</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>		position = numeric.add( position, numeric.mul(v_basis_vals[l], temp) );
	}

	<span class="hljs-keyword">return</span> position;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-281">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-281">&#182;</a>
              </div>
              <h4 id="curve_derivs-degree-knots-control_points-u-num_derivs-">curve_derivs( degree, knots, control_points, u, num_derivs )</h4>
<p>Determine the derivatives of a non-uniform, non-rational B-spline curve at a given parameter</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_derivs = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, u, num_derivs )</span> {</span>

	<span class="hljs-keyword">var</span> n = knots.length - degree - <span class="hljs-number">2</span>;
	<span class="hljs-keyword">return</span> verb.eval.nurbs.curve_derivs_given_n( n, degree, knots, control_points, u, num_derivs );

}</pre></div></div>
            
        </li>
        
        
        <li id="section-282">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-282">&#182;</a>
              </div>
              <h4 id="curve_derivs_given_n-n-degree-knots-control_points-u-num_derivatives-">curve_derivs_given_n( n, degree, knots, control_points, u, num_derivatives )</h4>
<p>Determine the derivatives of a non-uniform, non-rational B-spline curve at a given parameter
(corresponds to algorithm 3.1 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_derivs_given_n = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree, knots, control_points, u, num_derivatives )</span> {</span>

	<span class="hljs-keyword">if</span> ( verb.eval.nurbs.are_valid_relations(degree, control_points.length, knots.length ) === <span class="hljs-literal">false</span> ) {
		console.error(<span class="hljs-string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> dim = control_points[<span class="hljs-number">0</span>].length
		, du = <span class="hljs-built_in">Math</span>.min(num_derivatives, degree)
		, CK = verb.eval.nurbs.zeros_2d( du+<span class="hljs-number">1</span>, dim )
		, knot_span_index = verb.eval.nurbs.knot_span_given_n( n, degree, u, knots )
		, nders = verb.eval.nurbs.deriv_basis_functions_given_n_i( knot_span_index, u, degree, du, knots )
		, k = <span class="hljs-number">0</span>
		, j = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">0</span>; k &lt;= du; k++) {	
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= degree; j++) {
			CK[k] = numeric.add( CK[k], numeric.mul( nders[k][j], control_points[ knot_span_index - degree + j ] ) )
		}
	}
	<span class="hljs-keyword">return</span> CK;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-283">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-283">&#182;</a>
              </div>
              <h4 id="are_valid_relations-degree-num_control_points-knots_length-">are_valid_relations( degree, num_control_points, knots_length )</h4>
<p>Confirm the relations between degree (p), number of control points(n+1), and the number of knots (m+1)
via The NURBS Book (section 3.2, Second Edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree</li>
<li><em>Number</em>, integer number of control points</li>
<li><em>Number</em>, integer length of the knot vector (including duplicate knots)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Boolean</em>, whether the values are correct</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.are_valid_relations = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, num_control_points, knots_length )</span> {</span>

	<span class="hljs-keyword">return</span> ( num_control_points + degree + <span class="hljs-number">1</span> - knots_length ) === <span class="hljs-number">0</span> ? <span class="hljs-literal">true</span> : <span class="hljs-literal">false</span>;

}</pre></div></div>
            
        </li>
        
        
        <li id="section-284">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-284">&#182;</a>
              </div>
              <h4 id="curve_point-degree-knots-control_points-u-">curve_point( degree, knots, control_points, u)</h4>
<p>Compute a point on a non-uniform, non-rational b-spline curve</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_point = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, knots, control_points, u)</span> {</span>

	<span class="hljs-keyword">var</span> n = knots.length - degree - <span class="hljs-number">2</span>;
	<span class="hljs-keyword">return</span> verb.eval.nurbs.curve_point_given_n( n, degree, knots, control_points, u);

}</pre></div></div>
            
        </li>
        
        
        <li id="section-285">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-285">&#182;</a>
              </div>
              <h4 id="curve_point_given_n-n-degree-knots-control_points-u-">curve_point_given_n( n, degree, knots, control_points, u)</h4>
<p>Compute a point on a non-uniform, non-rational b-spline curve
(corresponds to algorithm 3.1 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Number</em>, integer degree of curve</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
<li><em>Array</em>, 2d array of control points, where each control point is an array of length (dim)  </li>
<li><em>Number</em>, parameter on the curve at which the point is to be evaluated</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, a point represented by an array of length (dim)</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.curve_point_given_n = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree, knots, control_points, u)</span> {</span>

	<span class="hljs-keyword">if</span> ( verb.eval.nurbs.are_valid_relations(degree, control_points.length, knots.length ) === <span class="hljs-literal">false</span> ) {
		console.error(<span class="hljs-string">'Invalid relations between control points, knot vector, and n'</span>);
		<span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
	}

	<span class="hljs-keyword">var</span> knot_span_index = verb.eval.nurbs.knot_span_given_n( n, degree, u, knots )
		, basis_values = verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index, u, degree, knots ) 
		, position = verb.eval.nurbs.zeros_1d( control_points[<span class="hljs-number">0</span>].length );

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt;= degree; j++ )	{
			position = numeric.add( position, numeric.mul( basis_values[j], control_points[ knot_span_index - degree + j ] ) );
		}

		<span class="hljs-keyword">return</span> position;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-286">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-286">&#182;</a>
              </div>
              <h4 id="zeros_1d-size-">zeros_1d(size)</h4>
<p>Generate a 1d array of zeros</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of rows</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 1d array of given size</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.zeros_1d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(size)</span> {</span>
  size = size &gt; <span class="hljs-number">0</span> ? size : <span class="hljs-number">0</span>;

  <span class="hljs-keyword">var</span> arr = [];

  <span class="hljs-keyword">while</span>(size--) {
    arr.push(<span class="hljs-number">0</span>);
  }

  <span class="hljs-keyword">return</span> arr;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-287">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-287">&#182;</a>
              </div>
              <h4 id="zeros_2d-rows-cols-">zeros_2d(rows, cols)</h4>
<p>Generate a 2D array of zeros</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of rows</li>
<li><em>Number</em>, integer number of columns</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 2d array of given size</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.zeros_2d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(rows, cols)</span> {</span>
  cols = cols &gt; <span class="hljs-number">0</span> ? cols : <span class="hljs-number">0</span>;
  rows = rows &gt; <span class="hljs-number">0</span> ? rows : <span class="hljs-number">0</span>;

  <span class="hljs-keyword">var</span> arr = [];
  <span class="hljs-keyword">var</span> cols_temp = cols;
  <span class="hljs-keyword">var</span> rows_temp = rows;

  <span class="hljs-keyword">while</span>(rows--) {
    arr.push([]);

    <span class="hljs-keyword">while</span>(cols_temp--) {
      arr[rows_temp-rows-<span class="hljs-number">1</span>].push(<span class="hljs-number">0</span>);
    }
    cols_temp = cols;
  }

  <span class="hljs-keyword">return</span> arr;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-288">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-288">&#182;</a>
              </div>
              <h4 id="zeros_3d-rows-cols-dim-">zeros_3d(rows, cols, dim)</h4>
<p>Generate a 3D array of zeros</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of rows</li>
<li><em>Number</em>, integer number of columns</li>
<li><em>Number</em>, integer depth (i.e. dimension of arrays in 2d matrix)</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 3d array of given size</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.zeros_3d = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(rows, cols, dim)</span> {</span>
  cols = cols &gt; <span class="hljs-number">0</span> ? cols : <span class="hljs-number">0</span>;
  rows = rows &gt; <span class="hljs-number">0</span> ? rows : <span class="hljs-number">0</span>;

  <span class="hljs-keyword">var</span> arr = [];
  <span class="hljs-keyword">var</span> cols_temp = cols;
  <span class="hljs-keyword">var</span> rows_temp = rows;

  <span class="hljs-keyword">while</span>(rows--) {
    arr.push([]);

    <span class="hljs-keyword">while</span>(cols_temp--) {
      arr[rows_temp-rows-<span class="hljs-number">1</span>].push( verb.eval.nurbs.zeros_1d(dim) );
    }
    cols_temp = cols;
  }

  <span class="hljs-keyword">return</span> arr;
}</pre></div></div>
            
        </li>
        
        
        <li id="section-289">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-289">&#182;</a>
              </div>
              <h4 id="deriv_basis_functions-u-degree-knots-">deriv_basis_functions( u, degree, knots )</h4>
<p>Compute the non-vanishing basis functions and their derivatives</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 2d array of basis and derivative values of size (n+1, p+1) The nth row is the nth derivative and the first row is made up of the basis function values.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.deriv_basis_functions = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, degree, knots )</span>
{</span>
	<span class="hljs-keyword">var</span> knot_span_index = verb.eval.nurbs.knot_span( degree, u, knots )
		, m = knots.length - <span class="hljs-number">1</span>
		, n = m - degree - <span class="hljs-number">1</span>;

	<span class="hljs-keyword">return</span> verb.eval.nurbs.deriv_basis_functions_given_n_i( knot_span_index, u, degree, n, knots );
}</pre></div></div>
            
        </li>
        
        
        <li id="section-290">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-290">&#182;</a>
              </div>
              <h4 id="deriv_basis_functions_given_n_i-knot_span_index-u-p-n-knots-">deriv_basis_functions_given_n_i( knot_span_index, u, p, n, knots )</h4>
<p>Compute the non-vanishing basis functions and their derivatives
(corresponds to algorithm 2.3 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer knot span index</li>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree</li>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, 2d array of basis and derivative values of size (n+1, p+1) The nth row is the nth derivative and the first row is made up of the basis function values.</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.deriv_basis_functions_given_n_i = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( knot_span_index, u, p, n, knots )</span>
{</span>
	<span class="hljs-keyword">var</span> ndu = verb.eval.nurbs.zeros_2d(p+<span class="hljs-number">1</span>, p+<span class="hljs-number">1</span>)
		, left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( p + <span class="hljs-number">1</span> )
		, right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( p + <span class="hljs-number">1</span> )
		, saved = <span class="hljs-number">0</span>
		, temp = <span class="hljs-number">0</span>
		, j = <span class="hljs-number">1</span>
		, r = <span class="hljs-number">0</span>;

	ndu[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;

	<span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt;= p; j++) {

		left[j] = u - knots[knot_span_index+<span class="hljs-number">1</span>-j];
		right[j] = knots[knot_span_index+j] - u;
		saved = <span class="hljs-number">0.0</span>;

		<span class="hljs-keyword">for</span> (r = <span class="hljs-number">0</span>; r &lt; j; r++) {

			ndu[j][r] = right[r+<span class="hljs-number">1</span>] + left[j-r];
			temp = ndu[r][j-<span class="hljs-number">1</span>] / ndu[j][r];

			ndu[r][j] = saved + right[r+<span class="hljs-number">1</span>]*temp;
			saved = left[j-r]*temp;

		}
		ndu[j][j] = saved;
	}


	<span class="hljs-keyword">var</span> ders = verb.eval.nurbs.zeros_2d(n+<span class="hljs-number">1</span>, p+<span class="hljs-number">1</span>)
		, a = verb.eval.nurbs.zeros_2d(<span class="hljs-number">2</span>, p+<span class="hljs-number">1</span>)
		, k = <span class="hljs-number">1</span>
		, s1 = <span class="hljs-number">0</span>
		, s2 = <span class="hljs-number">1</span>
		, d = <span class="hljs-number">0</span>
		, rk = <span class="hljs-number">0</span>
		, pk = <span class="hljs-number">0</span>
		, j1 = <span class="hljs-number">0</span>
		, j2 = <span class="hljs-number">0</span>;

	<span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt;= p; j++) {
		ders[<span class="hljs-number">0</span>][j] = ndu[j][p];
	}

	<span class="hljs-keyword">for</span> (r = <span class="hljs-number">0</span>; r&lt;=p; r++) {
		s1 = <span class="hljs-number">0</span>;
		s2 = <span class="hljs-number">1</span>;
		a[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;

		<span class="hljs-keyword">for</span> (k=<span class="hljs-number">1</span>; k&lt;=n ;k++)
		{
			d = <span class="hljs-number">0.0</span>;
			rk = r - k;
			pk = p - k;

			<span class="hljs-keyword">if</span> (r &gt;= k) {
				a[s2][<span class="hljs-number">0</span>] = a[s1][<span class="hljs-number">0</span>] / ndu[pk+<span class="hljs-number">1</span>][rk];
				d = a[s2][<span class="hljs-number">0</span>]*ndu[rk][pk];
			}

			<span class="hljs-keyword">if</span> (rk &gt;= -<span class="hljs-number">1</span>) {
				j1 = <span class="hljs-number">1</span>;
			} <span class="hljs-keyword">else</span> {
				j1 = -rk;
			}

			<span class="hljs-keyword">if</span> (r-<span class="hljs-number">1</span> &lt;= pk) {
				j2 = k-<span class="hljs-number">1</span>;
			} <span class="hljs-keyword">else</span> {
				j2 = p - r;
			}

			<span class="hljs-keyword">for</span> (j = j1; j &lt;= j2; j++) {
				a[s2][j] = ( a[s1][j] - a[s1][ j - <span class="hljs-number">1</span> ] ) / ndu[ pk + <span class="hljs-number">1</span> ][ rk + j ];
				d += a[s2][j]*ndu[rk+j][pk];
			}

			<span class="hljs-keyword">if</span> (r &lt;= pk)
			{
				a[s2][k] = -a[s1][k-<span class="hljs-number">1</span>]/ndu[pk+<span class="hljs-number">1</span>][r];
				d += a[s2][k] * ndu[r][pk];
			}

			ders[k][r] = d;
			j = s1;
			s1 = s2;
			s2 = j;
		}
	}

	r = p;
	<span class="hljs-keyword">for</span> (k = <span class="hljs-number">1</span>; k &lt;= n; k++) {
		<span class="hljs-keyword">for</span> (j = <span class="hljs-number">0</span>; j &lt;= p; j++) {
			ders[k][j] *= r;
		}
		r *= (p-k);
	}

	<span class="hljs-keyword">return</span> ders;

};</pre></div></div>
            
        </li>
        
        
        <li id="section-291">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-291">&#182;</a>
              </div>
              <h4 id="basis_functions-u-degree-knots-">basis_functions( u, degree, knots )</h4>
<p>Compute the non-vanishing basis functions</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree of function</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, list of non-vanishing basis functions</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.basis_functions = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( u, degree, knots )</span>
{</span>
	<span class="hljs-keyword">var</span> knot_span_index = verb.eval.nurbs.knot_span(u, degree, knots);
	<span class="hljs-keyword">return</span> verb.eval.nurbs.basis_functions_given_knot_span_index( knot_span_index, u, degree, knots );
};</pre></div></div>
            
        </li>
        
        
        <li id="section-292">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-292">&#182;</a>
              </div>
              <h4 id="basis_functions_given_knot_span_index-knot_span_index-u-degree-knots-">basis_functions_given_knot_span_index( knot_span_index, u, degree, knots )</h4>
<p>Compute the non-vanishing basis functions
(corresponds to algorithm 2.2 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer knot span index</li>
<li><em>Number</em>, float parameter</li>
<li><em>Number</em>, integer degree of function</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Array</em>, list of non-vanishing basis functions</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.basis_functions_given_knot_span_index = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( knot_span_index, u, degree, knots )</span>
{</span>
	<span class="hljs-keyword">var</span> basis_functions = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( degree + <span class="hljs-number">1</span> )
		, left = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( degree + <span class="hljs-number">1</span> )
		, right = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>( degree + <span class="hljs-number">1</span> )
		, saved = <span class="hljs-number">0</span>
		, temp = <span class="hljs-number">0</span>;

	basis_functions[<span class="hljs-number">0</span>] = <span class="hljs-number">1.0</span>;

	<span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> j = <span class="hljs-number">1</span>; j &lt;= degree; j++) {

		left[j] = u - knots[knot_span_index+<span class="hljs-number">1</span>-j];
		right[j] = knots[knot_span_index+j] - u;
		saved = <span class="hljs-number">0.0</span>;

		<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> r = <span class="hljs-number">0</span>; r &lt; j; r++) {

			temp = basis_functions[r] / ( right[r+<span class="hljs-number">1</span>] + left[j-r] );
			basis_functions[r] = saved + right[r+<span class="hljs-number">1</span>]*temp;
			saved = left[j-r]*temp;

		}

		basis_functions[j] = saved;
	}

	<span class="hljs-keyword">return</span> basis_functions;
};</pre></div></div>
            
        </li>
        
        
        <li id="section-293">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-293">&#182;</a>
              </div>
              <h4 id="knot_span-degree-u-knots-">knot_span( degree, u, knots )</h4>
<p>Find the span on the knot vector without supplying n</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer degree of function</li>
<li><em>Number</em>, float parameter</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, the index of the knot span</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.knot_span = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( degree, u, knots )</span>
{</span>

	<span class="hljs-keyword">var</span> m = knots.length - <span class="hljs-number">1</span>
		, n = m - degree - <span class="hljs-number">1</span>;

	<span class="hljs-keyword">return</span> verb.eval.nurbs.knot_span_given_n(n, degree, u, knots);

};</pre></div></div>
            
        </li>
        
        
        <li id="section-294">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-294">&#182;</a>
              </div>
              <h4 id="knot_span_given_n-n-degree-u-knots-">knot_span_given_n( n, degree, u, knots )</h4>
<p>Find the span on the knot vector knots of the given parameter
(corresponds to algorithm 2.1 from The NURBS book, Piegl &amp; Tiller 2nd edition)</p>
<p><strong>params</strong></p>
<ul>
<li><em>Number</em>, integer number of basis functions - 1 = knots.length - degree - 2</li>
<li><em>Number</em>, integer degree of function</li>
<li><em>Number</em>, float parameter</li>
<li><em>Array</em>, array of nondecreasing knot values</li>
</ul>
<p><strong>returns</strong> </p>
<ul>
<li><em>Number</em>, the index of the knot span</li>
</ul>

            </div>
            
            <div class="content"><div class='highlight'><pre>verb.eval.nurbs.knot_span_given_n = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">( n, degree, u, knots )</span>
{</span>
	<span class="hljs-keyword">if</span> ( u &gt;= knots[n+<span class="hljs-number">1</span>] )
	{
		<span class="hljs-keyword">return</span> n;
	}

	<span class="hljs-keyword">if</span> ( u &lt; knots[degree] )
	{
		<span class="hljs-keyword">return</span> degree;
	}

	<span class="hljs-keyword">var</span> low = degree
		, high = n+<span class="hljs-number">1</span>
		, mid = <span class="hljs-built_in">Math</span>.floor( (low + high) / <span class="hljs-number">2</span> );

	<span class="hljs-keyword">while</span>( u &lt; knots[ mid ] || u &gt;= knots[ mid + <span class="hljs-number">1</span> ] )
	{
		<span class="hljs-keyword">if</span> ( u &lt; knots[ mid ] )
		{
			high = mid;
		}
		<span class="hljs-keyword">else</span> 
		{
			low = mid;
		}
		mid = <span class="hljs-built_in">Math</span>.floor( (low + high) / <span class="hljs-number">2</span> );
	}

	<span class="hljs-keyword">return</span> mid;

};</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
